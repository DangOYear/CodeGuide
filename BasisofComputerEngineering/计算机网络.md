# 计算机网络

## 计算机网络体系结构

### 五层协议

+ 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。
+ 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：TCP、UDP
+ 网络层 ：为主机、路由器提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
+ 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
+ 物理层 ：考虑的是怎样在传输媒体上传输数据比特流。

### OSI七层

在上述基础上增加了

+ 表示层 ：数据压缩、加密以及数据描述。
+ 会话层 ：建立、管理会话。

### TCP/IP协议（实际使用的）

+ 应用层、TCP/UDP、IP、网络接口层
+ 只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

## 传输层

### TCP和UDP

+ 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
+ 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

### TCP三次握手

+ 过程

  ![image-20201011150138626](../img/计算机基础计算机网络TCP三次握手.png)

  假设 A 为客户端，B 为服务器端。

  首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

  A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。

  B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。

  A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。

  B 收到 A 的确认后，连接建立。

+ 三次握手原因

  第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

  客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

### TCP四次挥手

+ 过程

  ![image-20201011150215766](../img/计算机基础计算机网络TCP四次挥手.png)

  A 发送连接释放报文，FIN=1。

  B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。

  当 B 完成报文发送后，发送连接释放报文，FIN=1。

  A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

  B 收到 A 的确认后释放连接。

+ 四次挥手的原因

    客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，会进入 CLOSE_WAIT 状态。此时服务器可能还有未发送完成的数据，等到发送完毕之后，服务器会发送 FIN 连接释放报文。

+ TIME_WAIT

    客户端接收到服务器端的 FIN 报文后进入此状态，客户端并不会直接进入 CLOSED 状态，还需要等待2MSL。这么做是为了：

    + 确保最后一个确认报文能够到达。

### TCP可靠传输

超时重传

### TCP滑动窗口

To do

### TCP流量控制

流量控制是端到端的控制，主要解决的是使得接收端来得及处理发送端发来的请求。

该控制是通过控制发送端窗口的大小，从而影响发送方的发送速率。

### TCP拥塞控制

拥塞控制主要考虑的是网络的拥堵情况，目的是保证整体网络的畅通。

首先拥塞有两种情况，超时和收到三次重复的确认报文（接收端每次收到报文都会会对最后一个有序报文进行确认）。

超时说明此时网络已经非常的拥堵。

收到三次重复的确认报文说明网络状况还不是特别差。

+ 慢开始和拥塞避免

最开始cwnd = 1，

+ 快重传和快恢复

![img](../img/计算机基础计算机网络拥塞避免.png)



### 基于TCP的协议

+ FTP
+ Telnet
+ SMTP
+ POP3
+ HTTP

### 基于UDP的协议

+ DNS
+ SNMP
+ TFTP

## 应用层

### HTTP

URI包含URL和URN

统一资源标识符
统一资源定位符
统一资源名称

#### HTTP状态码

服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别          | 含义                 |
| ------ | ------------- | -------------------- |
| 1XX    | Informational | （信息性状态码）     |
| 2XX    | Success       | （成功状态码）       |
| 3XX    | Redirection   | （重定向状态码）     |
| 4XX    | Client Error  | （客户端错误状态码） |
| 5XX    | Server Error  | （服务器错误状态码） |

### HTTPS

HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443

#### HTTP存在以下问题

+ 使用明文进行通信，内容可能会被窃听；

+ 不验证通信方的身份，通信方的身份有可能遭遇伪装；

+ 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 
HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

#### HTTPS流程

HTTPS 需要使用一套 CA 数字证书，证书内会附带一个公钥 Pub，而与之对应的私钥 Private 保留在服务端不公开。

服务端收到请求，返回配置好的包含公钥 Pub 的证书给客户端。

客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示 HTTPS 警告信息，如果通过则继续。

客户端生成一个用于对称加密的随机 Key，并用证书内的公钥 Pub 进行加密，发送给服务端。

服务端收到随机 Key 的密文，使用与公钥 Pub 配对的私钥 Private 进行解密，得到客户端真正想发送的随机 Key。

服务端使用客户端发送过来的随机 Key 对要传输的 HTTP 数据进行对称加密，将密文返回客户端。

客户端使用随机 Key 对称解密密文，得到 HTTP 数据明文。

后续 HTTPS 请求使用之前交换好的随机 Key 进行对称加解密。

#### HTTPS

+ 存在加密解密过程，速度会比HTTP稍慢