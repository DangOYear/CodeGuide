{"./":{"url":"./","title":"简介","keywords":"","body":"CodeGuide 每节的README.md会概括该章节的重点。 编程学习整理的一些资料 建议使用电脑阅读，手机浏览器体验一般。 本文档主要是介绍各类计算机基础知识，面试不是目的。 本文的语言部分介绍应该是在有语言基础后的梳理。 欢迎贡献知识或更正错误，也可以提issue目前的最新需要学习的技术。 在线阅读 LeetCode刷题GitHub Java例子:本教程的所有Java代码会在这里显示 如果觉得可以的话，请大家收藏或推荐给身边的朋友一起来完善。 （重要）请大家尽量不要给本教程点赞，GitHub是贡献开源代码的地方，请给优质的代码项目点赞。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Interview/":{"url":"Interview/","title":"面试","keywords":"","body":"面试体验 在面试的过程中，会发现很多公司，甚至同一公司的不同部门，对于技术的要求点是完全不同的。有些特别关注多线程的知识，有些特别关注JVM的知识，有些公司关注Redis和MySQL等知识，而有的公司甚至不关心会不会Java，重点考察技术知识。 以下会整理一些笔者的一些面试部门和着重的考察点（To do）。 基础 Java虚拟机 OOM产生的场景 什么打破了双亲委派模型？ Spring Spring Bean生命周期 Spring Bean生命周期，你在实际中有什么应用 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BasisofComputerEngineering/":{"url":"BasisofComputerEngineering/","title":"计算机基础","keywords":"","body":"计算机基础 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BasisofComputerEngineering/计算机网络.html":{"url":"BasisofComputerEngineering/计算机网络.html","title":"计算机网络","keywords":"","body":"计算机网络 计算机网络体系结构 五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：TCP、UDP 网络层 ：为主机、路由器提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流。 OSI七层 在上述基础上增加了 表示层 ：数据压缩、加密以及数据描述。 会话层 ：建立、管理会话。 TCP/IP协议（实际使用的） 应用层、TCP/UDP、IP、网络接口层 只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 网络分层的优点 各层之间是独立的。某一层并不需要知道它下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可以将一个难以处理的复杂问题分解为若干个较容易处理的更小问题，这样，整个问题的复杂度就下降了。 灵活性好。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响，此外，对某一层提供的服务还可以进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。 结构上可分割开。各层都可以采用最合适的技术来实现。 易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个系统已被分解为若干个相对独立的子系统。 能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明。 传输层 TCP和UDP 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 TCP三次握手 过程 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 TCP四次挥手 过程 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 完成报文发送后，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，会进入 CLOSE_WAIT 状态。此时服务器可能还有未发送完成的数据，等到发送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，客户端并不会直接进入 CLOSED 状态，还需要等待2MSL。这么做是为了： 确保最后一个确认报文能够到达。 TCP可靠传输 超时重传 TCP滑动窗口 To do TCP流量控制 流量控制是端到端的控制，主要解决的是使得接收端来得及处理发送端发来的请求。 该控制是通过控制发送端窗口的大小，从而影响发送方的发送速率。 TCP拥塞控制 拥塞控制主要考虑的是网络的拥堵情况，目的是保证整体网络的畅通。 首先拥塞有两种情况，超时和收到三次重复的确认报文（接收端每次收到报文都会会对最后一个有序报文进行确认）。 超时说明此时网络已经非常的拥堵。 收到三次重复的确认报文说明网络状况还不是特别差。 慢开始和拥塞避免 最开始cwnd = 1， 快重传和快恢复 基于TCP的协议 FTP Telnet SMTP POP3 HTTP 基于UDP的协议 DNS SNMP TFTP 应用层 HTTP URI包含URL和URN 统一资源标识符 统一资源定位符 统一资源名称 HTTP状态码 服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational （信息性状态码） 2XX Success （成功状态码） 3XX Redirection （重定向状态码） 4XX Client Error （客户端错误状态码） 5XX Server Error （服务器错误状态码） HTTPS HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443 HTTP存在以下问题 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 HTTPS流程 HTTPS 需要使用一套 CA 数字证书，证书内会附带一个公钥 Pub，而与之对应的私钥 Private 保留在服务端不公开。 服务端收到请求，返回配置好的包含公钥 Pub 的证书给客户端。 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示 HTTPS 警告信息，如果通过则继续。 客户端生成一个用于对称加密的随机 Key，并用证书内的公钥 Pub 进行加密，发送给服务端。 服务端收到随机 Key 的密文，使用与公钥 Pub 配对的私钥 Private 进行解密，得到客户端真正想发送的随机 Key。 服务端使用客户端发送过来的随机 Key 对要传输的 HTTP 数据进行对称加密，将密文返回客户端。 客户端使用随机 Key 对称解密密文，得到 HTTP 数据明文。 后续 HTTPS 请求使用之前交换好的随机 Key 进行对称加解密。 HTTPS 存在加密解密过程，速度会比HTTP稍慢 HTTP2 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BasisofComputerEngineering/操作系统.html":{"url":"BasisofComputerEngineering/操作系统.html","title":"操作系统","keywords":"","body":"操作系统 简介 操作系统是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。---维基百科 进程管理 进程/线程 进程 资源分配的基本单位 线程 调度的基本单位 区别 线程不拥有资源，只能访问隶属于进程的资源 同一进程下线程切换不会引起进程切换，不同进程下线程切换会引起进程切换 线程可以通过读取同一进程数据进行通信，进程间通信需要IPC 进程调度 进程同步 死锁 死锁的必要条件 互斥条件：资源不能被共享，只能由一个进程使用； 请求与保持条件：已经得到资源的进程可以再次申请新的资源； 非剥夺条件：已经分配的资源不能从相应的进程中被强制地剥夺； 循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。 进程通信 管道 FIFO 消息队列 信号量 共享存储 套接字 内存管理 设备管理 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BasisofComputerEngineering/编译原理.html":{"url":"BasisofComputerEngineering/编译原理.html","title":"编译原理","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Algorithms/笔试面试算法.html":{"url":"Algorithms/笔试面试算法.html","title":"算法","keywords":"","body":"笔试面试算法 记录一些面经中的算法 排序实现 冒泡排序 堆排序 快速排序 二叉树 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/":{"url":"Java/","title":"Java","keywords":"","body":"Java Java语言基础知识 JVM的基础知识 Java并发的知识 Java容器的知识 JavaIO的一些知识 （重要）不针对Java 0基础的，最好看之前有基本的Java基础 Java8新特性 Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java基础.html":{"url":"Java/Java基础.html","title":"Java基础","keywords":"","body":"Java基础 Java简介 语言特性 一种编译型语言（编译成字节码） 完全面向对象的 平台无关性 支持多线程 支持网络编程 拥有最多类库的语言之一 自动内存管理 类只支持单继承但是可以实现多个接口 JDK和JRE JDK（Java Development Kit）Java开发套件。 JRE（Java Runtime Environment）Java运行时环境。 开发Java程序需要安装JDK，如果只是运行Java编写的文件，则安装JRE就足够了。 基本类型及其占用的bit数 Java共有8个基本类型 字符类型char（16） 布尔类型boolean（单boolean与int相同，boolean数组中单个boolean与byte相同） 数值类型byte（8）、short（16）、int（32）、long（64）、float（32）、double（64） 面向对象三大特性 封装 隐藏对象的属性，仅向外面提供访问的接口 继承 多态 类与接口 区别 一个类可以实现implements多个接口，但是可以extends多个接口，接口可以extends多个接口 接口的方法默认是public而且不能有实现（1.8之后可以有实现），抽象类可以有非抽象的方法，抽象方法可以有public、protected、default这些修饰符。 接口中只能存在static、final的变量 抽象是对类的抽象，接口是对行为的抽象。 字符串 类型 String StringBuffer StringBuilder String中的字符串是final的无法修改，可以修改指向的字符串常量。 String和StringBuffer是线程安全的，但StringBuffer的效率会低于StringBuilder。 包（Package） 包的作用 包的出现是为了更好的组织类。 相关的类和接口可以组织到一个包里 同名的类可以组织到不同的包里来区分 包访问权限 包的导入 全部导入 import java.util.*;（不推荐） 导入具体的 import java.util.Arrays;（推荐） 静态导入 import static java.lang.Math.PI; double r = cos(PI * theta)。静态导入时不需要指定类。 通过包访问包的成员 x.xx y = new x.xx(); 注解 异常 Error一般JVM就会终止线程 Exception中有两类，一类可检查异常，一类运行时异常。 finally不被执行的可能情况 System.exit() 泛型 枚举 序列化 实现序列化需要 implements Serializable 如果有不想要序列化的字段可以用transient Lambda表达式（包含流行的Stream） 反射 可以使用e.getClass()或者Class.forName(className)来获取Class对象 Object的方法 为什么重写 equals 时必须重写 hashCode 方法 两个对象相等，hashcode一定相等 两个对象不等，hashcode不一定不等 hashcode相等，两个对象不一定相等 hashcode不等，两个对象一定不等 Java枚举 Java枚举是一个特殊的类。 表示一组常量。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/LambdaStream.html":{"url":"Java/LambdaStream.html","title":"Lambda使用","keywords":"","body":"Lambda、Stream Lambda 函数式接口 自定义函数式接口 @FunctionalInterface interface SayHello { void sayMessage(String message); } public class GreetingService { public static void main(String[] args) { SayHello sayHello = message -> { System.out.println(\"Say Hello \" + message); }; sayHello.sayMessage(\"Ni hao\"); } } 内置函数式接口 内置的函数式接口主要分为以下四大类 Function、Comsumer、Predicate、Supplier Function import java.util.function.BiFunction; /** * @author SaltedFish * @date 2021/2/18 * 一个接受两个输入参数的方法，并且返回一个结果 */ public class FunctionDemo { public static void main(String[] args) { BiFunction biFunction = (a, b) -> a + b; System.out.println(biFunction.apply(1, 2)); } } Comsumer import java.util.function.Consumer; /** * @author SaltedFish * @date 2021/2/18 * 接受一个输入参数并且无返回的操作 */ public class ConsumerDemo { public static void main(String[] args) { int b = 2; Consumer consumer = (a) -> System.out.println(a + b); consumer.accept(1); } } Predicate import java.util.function.Predicate; /** * @author SaltedFish * @date 2021/2/18 * 接受一个输入参数，返回一个布尔值结果。 */ public class PredicateDemo { public static void main(String[] args) { int b = 1; Predicate biPredicate = a -> a > b; System.out.println(biPredicate.test(2)); } } Supplier import java.util.function.Supplier; /** * @author SaltedFish * @date 2021/2/18 * 无参数，返回一个结果。 */ public class SupplierDemo { public static void main(String[] args) { int a = 1; int b = 2; Supplier supplier = () -> a + b; System.out.println(supplier.get()); } } Stream（日常开发中经常会用到） stream是从Java8开始引入的。用来“做什么而非怎么做”的方式处理集合。 stream提供了一种更直观的操作容器的方式。之前操作容器往往需要显式的使用循环。而使用stream之后，对容器的处理更加直观了。 stream方法实现在Collection接口中。 常用的操作 创建流 操作名 操作介绍 Stream filter(Predicate predicate); 产生一个满足当前条件P的元素 count 产生当前流中元素的个数 并行操作 在产生流的过程中可以使用parallelStream()产生并行流 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java容器/":{"url":"Java/Java容器/","title":"Java容器","keywords":"","body":"Java容器 Java容器的一些介绍 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java容器/Java容器概述.html":{"url":"Java/Java容器/Java容器概述.html","title":"Java容器简介","keywords":"","body":"Java容器 分类 Java容器主要分为Collection和Map两类 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java容器/Java容器源码剖析.html":{"url":"Java/Java容器/Java容器源码剖析.html","title":"Java容器源码分析","keywords":"","body":"Java容器源码剖析 ArrayList源码 LinkedList源码 HashMap源码 HashMap成环原因 假设1下面有a、b两个元素 每次扩容transfer，都是倒置。 线程1循环完毕后。其实线程2看到的 成环原因 成环原因 HashMap 为什么Hashmap是两次幂 (n-1)&做hash来获得桶 做resize的时候会非常的方便 JDK1.8之后单个桶元素大于8个会使用红黑树 HashMap和HashTable的区别 线程安全和线程不安全 HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 HashTable直接使用对象的hashCode。而HashMap重新计算hash值 HashMap允许null，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断 Hashtable是继承Dictionary类，HashMap继承AbstractMap。 JDK1.7 JDK1.8 ConcurrentHashMap源码 上面是Segment，设置好后就不能变化。默认是16个。 扩容只会扩展到原来的两倍。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/JavaIO.html":{"url":"Java/JavaIO.html","title":"JavaIO","keywords":"","body":"JavaIO BIO、NIO、AIO区别 BIO（Blocking IO） 同步阻塞I/O模式 在读入和写入数据操作完成前，线程会一直阻塞在那里。 可以使用多线程进行处理（提高并发性）。 NIO（Non-Blocking IO/New IO） AIO（Asynchronous IO） By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java网络编程.html":{"url":"Java/Java网络编程.html","title":"Java网络编程","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/":{"url":"Java/EffectiveJava/","title":"EffectiveJava","keywords":"","body":"Effective Java 第三版 主要参考的是EffectiveJava和http://veng.gitee.io/effective-java-third-edition/。 本教程并不是翻译，只是对书本和其他大佬文章的总结。可能有疑惑的地方也会加上本人的注释。 其中有些本人觉得啰嗦或者不太实用的部分会略去。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/1.创建和销毁对象.html":{"url":"Java/EffectiveJava/1.创建和销毁对象.html","title":"创建和销毁对象","keywords":"","body":"创建和销毁对象 第1项 考虑静态工厂方法而不是构造函数 一个类可以为客户提供静态工厂方法，而不是采用构造函数来实例化。 public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE; } 使用静态工厂方法有优点也有缺点 优点 静态工厂方法是有名称的，可以取一个合适的名字，这样子更易于阅读。 //构造函数 BigInteger(int, int, Random) //静态工厂方法 BigInteger.probablePrime //静态工厂方法更清晰，尤其是当构造函数有多个的时候 静态函数不需要在每次被调用的时候创建一个新对象。不可变的类可以使用预先构造的实例，其他的类在构建时间进行缓存。类似于享元模式。 返回的对象可以是返回类型的任何子类的实例对象。灵活性更高。 静态工厂方法返回对象的类可以随着每次调用而变化。可以根据调用参数返回不同的类，只要这些类是声明的类的子类。 返回的对象所属的类，在编写包含该静态工厂方法的类时可以不必存在。 缺点 类如果不含公有的或者受保护的构造函数，就不能被子类化。 很难在代码中找到。 第2项 当面临多个参数的构造器时考虑使用构建器 当创建实例时参数特别多时，除了使用构造函数，更多应该考虑构建器。 // Builder Pattern public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder { // Required parameters private final int servingSize; private final int servings; // Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val) { calories = val; return this; } public Builder fat(int val) { fat = val; return this; } public Builder sodium(int val) { sodium = val; return this; } public Builder carbohydrate(int val) { carbohydrate = val; return this; } public NutritionFacts build() { return new NutritionFacts(this); } } private NutritionFacts(Builder builder) { servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; } } 现在使用构建器只要使用lombok的@Builder注解类即可 第3项 用私有构造器或者枚举类型强化Singleton属性 Singleton指仅仅被实例化一次的类，即单例。 实现单例第一种 // Singleton with public final field public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() { ... } public void leaveTheBuilding() { ... } } 但是有特权的client可以借助AccessibleObject.setAccessible方法反射性的调用私有构造函数。如果需要防御此攻击，则修改构造函数，使得创建第二个实例时抛出异常。 实现Singleton的第二种 静态工厂方法 // Singleton with static factory public class Elvis { private static final Elvis INSTANCE = new Elvis(); private Elvis() { ... } public static Elvis getInstance() { return INSTANCE; } public void leaveTheBuilding() { ... } } 因为private static final Elvis INSTANCE = new Elvis();是final的，所以永远保存着相同的对象引用。 灵活性高，可以决定类是否是Singleton。 如果应用需要，可以编写泛型单例工厂。 还有一个好处是一个函数的引用可以当作一个supplier使用。比如Elvis::instance是一个Supplier。 怀疑这里应该是Elvis::getInstance 原书这里不熟悉函数式接口的读者可能会有疑惑。我在这里给出示例代码。 import java.util.function.Supplier; /** * Effective Java item 3 */ class Elvis { private static final Elvis INSTANCE = new Elvis(); private Elvis() { } public static Elvis getInstance() { return INSTANCE; } public void leaveTheBuilding() { } } public class SupplierDemo { private static Elvis getElvis(Supplier stringSupplier) { return stringSupplier.get(); } public static void main(String[] args) { System.out.println(getElvis(Elvis::getInstance)); } } 如果不需要这些优点，还是使用第一种使用公有方法创建。 为了使得以上方法创建的单例类，可以实现可序列化。应该将所有的instance fields都设置成transient。 否则反序列化的时候，单例会失效。 // readResolve method to preserve singleton property private Object readResolve() { // Return the one true Elvis and let the garbage collector // take care of the Elvis impersonator. return INSTANCE; } 第三种实现单例的方法是提供只包含一个元素的enum枚举。 // Enum singleton - the preferred approach public enum Elvis { INSTANCE; public void leaveTheBuilding() { ... } } 第三种往往是实现单例最佳的方式。 如果你的单例必须扩展Enum以外的super class，则不能使用此方法（尽管你可以声明枚举来实现接口）。 第4项 使用私有构造器强化不可实例化 如果需要只有静态方法和静态字段的工具类，比如在Java中的java.lang.Math和java.util.Arrays。 这样的工具类对其进行实例化是完全没有意义的。不提供构造器的时候，其实编译器会提供无参的构造器。可能会不小心实例化该类。 使用抽象类来组织也是不不可行的，因为可以继承抽象类，且继承的类可以被实例化。这样反而会误导使用者，以为该类是专门拿来继承用的。 因为可以采用私有的构造器来防止实例化。 // Noninstantiable utility class public class UtilityClass { // Suppress default constructor for noninstantiability private UtilityClass(( { throw new AssertionError(); } ... // Remainder omitted } 添加抛出异常的语句可以防止在类内部调用构造器。 第5项 固定资源推荐使用依赖注入 许多类依赖一个或者多个不可变的资源。例如一个拼写检查器依赖于一个字典。 常见的做法是把它实现成一个静态工具类。 // Inappropriate use of static utility - inflexible & untestable! public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() {} // Noninstantiable public static boolean isValid(String word) { ... } public static List suggestions(String typo) { ... } } 同样的，实现成一个单例也是常见的做法。 // Inappropriate use of singleton - inflexible & untestable! public class SpellChecker { private final Lexicon dictionary = ...; private SpellChecker(...) {} public static INSTANCE = new SpellChecker(...); public boolean isValid(String word) { ... } public List suggestions(String typo) { ... } } 这些方法都不是令人满意的。因为他们假定只有一本字典。实际上，每个语言都有自己的字典。 我们可以通过使得字典变成非final的字段，并且增加可以修改字典的方法。这样的方式在并发环境下是糟糕的。静态工具类和单例的行为通过固定的静态资源作为参数来定义是不合理的。 一种简单的满足该要求的是在构造函数中传入静态资源。字典是拼写检查器的依赖项，在创建的时候注入。 // Dependency injection provides flexibility and testability public class SpellChecker { private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) { this.dictionary = Objects.requireNonNull(dictionary); } public boolean isValid(String word) { ... } public List suggestions(String typo) { ... } } 还有一种不同的方式是向构造函数传入资源工厂。 Mosaic create(Supplier tileFactory) { ... } 使用Supplier并且使用泛型约束类的类型。 虽然依赖注入极大的增强了灵活性和可测试性。但是它可能会使得大型项目变的混乱。尤其是有成千上万个依赖的时候。这时我们可以使用依赖注入框架。比如Dagger、Guice或者Spring来管理。 第6项 避免创建不必要的对象 当需要使用功能相同的对象时，最好能重用它而不是进行创建操作。 不可变对象天生是可重用的。 以下操作是不可取的，每次使用相同的字符串，都会创新新的对象。 String s = new String(\"bikini\"); // DON'T DO THIS! 应该使用以下方式，这样每次使用相同的字符串时，不会创建新的对象。 String s = \"bikini\"; 如果不可变类同时提供了构造函数和静态工厂方法，最好使用静态工厂方法。 比如应该使用静态工厂方法Boolean.valueOf(String)而不是Boolean(String)。构造函数在每次调用时，都会生成一个新的对象，而静态工厂方法并不会。 除了重用不可变对象，如果明确知道可变对象不会被修改，也可以对其进行重用。 // Performance can be greatly improved! static boolean isRomanNumeral(String s) { return s.matches(\"^(?=.)M*(C[MD]|D?C{0,3})\" + \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\"); } 有些对象创建的代价远远大于其他对象。 如果需要重复的使用这些对象，最好能够缓存他们。 假设你在写一个判断罗马字符的正则表达式。如下所示 // Performance can be greatly improved! static boolean isRomanNumeral(String s) { return s.matches(\"^(?=.)M*(C[MD]|D?C{0,3})\" + \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\"); } 在有性能要求的时候这样使用是不合理的。因为把正则表达式编译成状态机是代价高昂的。 可以使用以下方法。 // Reusing expensive object for improved performance public class RomanNumerals { private static final Pattern ROMAN = Pattern.compile( \"^(?=.)M*(C[MD]|D?C{0,3})\" + \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\"); static boolean isRomanNumeral(String s) { return ROMAN.matcher(s).matches(); } } 该方法在频繁调用该正则表达式时，可以获得巨大的性能提升。 这样的方式不仅提高了性能，而且增强了可读性。一看就知道该正则表达式的用途。 不推荐在这里将资源创建设置成懒加载。如果有性能改进的修改不容易对其进行量化。 当一个对象是不可变的情况下，可以安全的重复使用它。在其他情况下，并没有这么明显。在这种情况下可以使用适配器。 比如Map接口的keySet()方法，返回了Map接口中的所有key。看起来好像是创建了不同key的Set，其实其中返回的可能是相同的keySet。 创建不必要对象的另一种方式是自动装箱。 比如以下代码。在频繁的对i进行装箱。 // Hideously slow! Can you spot the object creation? private static long sum() { Long sum = 0L; for (long i = 0; i 在这里可以尽量使用基本类型。避免频繁装箱。 当然这里并不是让大家不要创建对象。其实创建小对象的代价是很小的。尤其是在目前高度优化的JVM上。 维护对象池一个很糟糕的方式，除非这些对象的创建代价足够大。例如数据库连接池。维护对象池会使得代码很乱，增加内存占用且影响性能。 第6项说的是，你应该重用对象而不是去创建。而第50项说的是你应该创建一个新的对象。如果重用对象会带来潜在的错误和安全问题。那么最好还是重新创建它。这两项并不是完全矛盾的。 第7项 清理过期对象的引用 虽然Java是一个自动垃圾回收的语言。但是不意味着不需要考虑内存管理。 考虑以下的简单的栈实现 // Can you spot the \"memory leak\"? public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; } /** * Ensure space for at least one more element, roughly * doubling the capacity each time the array needs to grow. */ private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } } 这里存在一个内存泄漏。当Stack增大后又缩小，原先增大的部分并不会被回收，因为elements中还保留着其引用。 public Object pop() { if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // Eliminate obsolete reference return result; } 解决方法也很简单，将其手动设置为null。 当然在所有地方都显式的将不再需要的对象都设置成null大可不必。这应该是一种解决出错的手段而不是规范。 什么时候需要清空引用呢，当我们的程序是自己管理内存的时候，比如上述Stack，GC并不知道那些elements是没有在使用，那些是在使用的。因此不用的部分应该显式的设置成null。因此如果是自己管理内存的代码，都应该警惕这种风险。 另一种内存泄漏的源头来自于缓存。 当创建一个缓存项的时候，很容易忘记它。从而导致它长期在缓存内占用内存。如果你实现的缓存项是有引用才有存在的意义的，那么可以使用WeakHashMap。 当缓存项的生命周期不是那么明确的时候，随着时间流逝，有些项变得越来越不重要。这时候就应该使用后台线程（Timer或者ScheduledThreadPoolExecutor）去清理它，也可以在新增项的时候去清理。LinkedHashMap 类利用它的 removeEldestEntry 方法可实现了后一种方案。对于更加复杂的缓存，必须直接使用 java.lang.ref（这里面包含了各种类型的引用等类）。 第三种常见的内存泄漏时监听器和其他回调。如果实现了API去注册回调，但是没有去显式的去取消它们，除非你采取某种动作，否则会积累下来。确保回调立即被当做垃圾回收的最佳方法是只保存它们的弱引用(weak reference)，将它们保存成 WeakHashMap 中的键。 内存泄漏通常不会表现出明显的失败迹象，往往只有通过仔细检查代码，或者借助于堆剖析工具（Heap Profiler）才能发现内存泄漏问题。因此，如果能在内存泄漏发生之前就知道如何预测此类问题，并阻止它们发生，那是最好不过的了。 第8项 避免使用终结方法和清理方法（In Progress） 终结方法finalize() 清理方法cleaner() 终结方法是不可预测的，危险的，通常也是不必要的。 使用终结方法会有不可预测的行为，低劣的性能和可移植性问题。 Java9中替代终结方法的是清理方法。清理方法稍微比终结方法不危险一些，但是同样是不可预测的。 这两个方法并不保证会立马执行。而且它的及时性主要依赖于JVM。 第9项 优先使用try-with-resources而不是try-finally java中的库包含很多需要手动调用close方法的资源。比如InputStream，OutputStream 和 java.sql.Connection。clients经常会忘记关闭资源，造成可预见的性能问题。 虽然很多资源使用finalizers方法作为保险，但是它并不能很好的工作。 在之前try-finally是一种关闭资源的很好的方式，即使出现了异常了也会调用finally语句。 // try-finally - No longer the best way to close resources! static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } 似乎看起来还不错，但是如果有第二个资源呢？ // try-finally is ugly when used with more than one resource! static void copy(String src, String dst) throws IOException { InputStream in = new FileInputStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) >= 0) out.write(buf, 0, n); } finally { out.close(); } } finally { in.close(); } } 所以应该使用try-with-resource // try-with-resources - the the best way to close resources! static String firstLineOfFile(String path) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } } // try-with-resources on multiple resources - short and sweet static void copy(String src, String dst) throws IOException { try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst)) { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) >= 0) out.write(buf, 0, n); } } try-with-resources方法更加短、可读性更好。该种方法也可以添加catch语句 // try-with-resources with a catch clause static String firstLineOfFile(String path, String defaultVal) { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch (IOException e) { return defaultVal; } } By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/2.对所有对象都适用的方法.html":{"url":"Java/EffectiveJava/2.对所有对象都适用的方法.html","title":"对所有对象都适用的方法","keywords":"","body":"对于所有对象都通用的一些方法原则 第10项 重写equals时 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/3.类与接口.html":{"url":"Java/EffectiveJava/3.类与接口.html","title":"类与接口","keywords":"","body":"类与接口 第15项 最小化类与成员的可访问性 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/4.泛型.html":{"url":"Java/EffectiveJava/4.泛型.html","title":"泛型","keywords":"","body":"泛型 第26项 不要使用原始类型 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/5.枚举和注释.html":{"url":"Java/EffectiveJava/5.枚举和注释.html","title":"枚举与注释","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/6.Lambda和Stream.html":{"url":"Java/EffectiveJava/6.Lambda和Stream.html","title":"Lambda和Stream","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/7.方法.html":{"url":"Java/EffectiveJava/7.方法.html","title":"方法","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/8.通用编程.html":{"url":"Java/EffectiveJava/8.通用编程.html","title":"通用编程","keywords":"","body":"通用编程 第49项 检查参数的有效性 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/9.异常.html":{"url":"Java/EffectiveJava/9.异常.html","title":"异常","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/EffectiveJava/11.序列化.html":{"url":"Java/EffectiveJava/11.序列化.html","title":"序列化","keywords":"","body":"序列化 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/":{"url":"Java/Java虚拟机/","title":"Java虚拟机","keywords":"","body":"Java虚拟机 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/0.Java虚拟机重点.html":{"url":"Java/Java虚拟机/0.Java虚拟机重点.html","title":"Java虚拟机重点","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/1.Java虚拟机简介.html":{"url":"Java/Java虚拟机/1.Java虚拟机简介.html","title":"Java虚拟机简介","keywords":"","body":"Java虚拟机简介 推荐参考书 《深入理解Java虚拟机:JVM高级特性与最佳实践》 为什么会有Java虚拟机 Java提出了，一次编写，到处运行的概念。Java编译后生成JVM可以识别的字节码。这就需要JVM对各个平台进行适配。 目前比较流行的虚拟机与未来 HotSpot是目前比较主流的虚拟机。 但值得关注的是GraalVM,尤其是该虚拟机可以将C++等语言的源代码或者代码的中间表示都转化成其可以接受的中间表示。可以作为任何语言的运行平台进行使用。 Java首次加载慢 第一次加载慢，要进行类加载等操作。 尤其现在的微服务甚至FASS(函数即服务中函数，而Java在很多时候需要预热才能达到最佳性能) By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/2.Java内存区域与内存溢出异常.html":{"url":"Java/Java虚拟机/2.Java内存区域与内存溢出异常.html","title":"Java内存区域与内存溢出异常","keywords":"","body":"Java内存区域与内存溢出异常 Java内存区域 Java内存各区域简介 程序计数器 学习过操作系统或者计算机组成原理的同学应该都明白，大致就相当于PC寄存器。 程序计数器保存着下一条需要执行的字节码指令。 每条线程都有自己独立的程序计数器，互不干扰。 Java虚拟机栈 每个方法在被执行的时候，都会开辟一个栈帧。一个方法被调用到被执行完毕的过程，对应着一个栈帧从入栈到出栈。学习过《深入理解计算机系统》的小伙伴对这块应该会比较熟悉。 申请栈成功就不会OOM(OutOfMemoryError)，但是申请到栈空间用完会有StackOverFlowError异常。如果申请栈空间的时候就失败，还是会OOM的。 本地方法栈 本地方法是虚拟机使用到的本地(Native)方法。 Java堆 Java堆是这几个内存区域中需要重点关注的部分，是垃圾收集器管理的内存区域。 现代垃圾收集器往往是分代收集。 如果Java堆无法再扩展时，会抛OOM异常。 方法区 方法区是各个线程共享的区域。主要用于存储类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。 JDK7中将字符串常量池、静态变量等移出。 JDK8中所有的内容都转移到了元空间(Meta-Space)中。 如果方法区无法满足内存分配需求，将抛出OOM错误。 运行时常量池(方法区的一部分) Class文件中除了有类的版本、字段、方法、接口等描述信息。还有一项是常量池表，用于存放各种字面量与符号引用。 直接内存 直接访问内存，可能会超过物理内存限制，导致OOM。比如Java中的NIO。 Java对象 对象的创建过程 当Java虚拟机执行一条new语句时，会先检查能否在常量池中定位到一个类的符号引用，和该类是否已经被加载、解析和初始化过。 类检查通过后，虚拟机为新生对象分配内存。对象所需的内存在类加载完成后即可确定。 为新生对象分配内存的过程类似于操作系统分配内存。 分配完成后Java虚拟机还要对对象进行必要的设置，例如对象指向的类，对象的哈希码，对象的GC分代年龄。 对象的创建已经基本完成 执行构造函数设置对象中的值 对象的内存分布 对象存储布局可以分为三个部分：对象头，实例数据，对齐填充。 MarkWord 可以触发OOM的几个方法 Java heap space 没有空间存放新创建的对象 永久代 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/3.垃圾收集器与内存分配策略.html":{"url":"Java/Java虚拟机/3.垃圾收集器与内存分配策略.html","title":"垃圾收集器与内存分配策略","keywords":"","body":"垃圾收集器与内存分配策略 概述 主要解决以下问题 哪些内存需要回收 什么时候回收 如何回收 判断对象是否可以存活 引用计数算法 在对象中添加一个引用计数器，每当有一个地方引用就加1，少一个引用就减1。 主流的不采用引用计数法。 优点：原理简单、判断效率高。 缺点：循环引用无法判断。 可达性分析法 通过一系列称为GC Roots的根对象做为起始节点集。 从这些节点开始根据引用关系向下搜索，搜索过程中所走过的路径称为引用链。 如果某个对象没有引用链，则说明此对象不再被使用。 GC Root主要包括以下几类 在虚拟机栈(栈帧中的本地变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 在方法区中类静态属性引用的对象，例如Java类的引用类型静态变量。 在方法区常量引用的对象，例如字符串常量池，例如字符串常量池里的引用。 在本地方法栈中JNI(Native方法)引用的对象。 Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻内存的异常对象(比如NullPointException、OutOfMemoryError)等，还有系统类加载器。 所有被同步锁(synchronized)持有的对象 反应Java虚拟机内部情况的JMXBean、JVM TI中注册的回调、本地代码缓存等。 除了这些固定的之外。根据垃圾收集器的不同和当前回收区域的不同，还会有其他对象临时性加入。 比如在局部回收时，本区域的对象可能被其他区域所引用。此时关联区域的对象也会被加入GCRoots 引用类型 强引用。最平常使用的类型。只要引用还在，垃圾收集器永远不会回收 软引用。在系统将要发生内存异常钱，会把这些对象列进回收范围内进行第二次回收。使用SoftReference类实现。 弱引用。只能生存到下一次垃圾收集发生为止。下一次垃圾收集开始时，都会被回收掉。WeakReference实现 虚引用。为一个对象设置虚引用关联的唯一目的是为了能在这个对象被回收时收到一个系统通知。PhantomReference 虚引用主要是为了使得指向的对象被回收时可以收到通知。这时可以根据情况进行相应的处理。 标记不可到达后 即使被标记为不可达，也不是非死不可。 宣布一个对象死亡，要经历两次标记。 没有引用链是第一次，第二次是是否需要执行finalize()方法 在finalize()中只要重新与引用链上的任何一个对象建立关联即可。(不建议使用) 方法区回收 在方法区进行回收性价比是比较低的。 主要回收以下两部分： 废弃的常量 如字符串\"java\"，没有一个字符串引用，则会被回收 不再使用的类型。类型回收的条件 该类的所有实例都已经被回收 加载该类的类加载器都已经被回收(很难达成，除了OSGi、JSP的重加载) 该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力。免得方法区有过大的内存压力。 垃圾收集算法 分代收集理论 当前的垃圾收集器一般都是分代收集。 依据存活的次数分配到不同的区域存储。 但是内存可能会有跨代引用的问题。 弱分代假说：绝大多数对象都是朝生夕灭的 强分代假说：经历多次GC都没有被收集的对象能存活更久 跨代引用假说：跨代引用相对于同代引用来说仅占极少数(避免扫描整个老年代，而是在新生代上建立一个数据结构\"记忆集\"),这个数据集把老年代划分为若干小块，标识出老年代哪一块内存存在跨代引用，只扫描该区域，减少了扫描的范围） 分代收集的一些定义 部分收集(Partial GC):指目标不是完整收集整个Java堆的垃圾收集 新生代收集(Minor GC/Young GC):目标只是新生代的垃圾收集。 老年代收集(Major GC/Old GC):目标只是老年代的垃圾收集。只有CMS才会有。 混合收集(Mixed GC):目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集 标记-清除算法 分为两个阶段 标记:标记所有需要回收的对象 回收:统一回收所有被标记的对象 缺点: 如果需要被回收的特别多，执行效率随着对象增常而降低 内存空间碎片化，大对象可能会没有足够的连续空间存放触发GC 标记-复制算法 目前大多的商用Java虚拟机采用了标记-复制算法回收新生代。 将可用内存分为两块，每次只使用其中的一块。 其中一块用完了，将仍旧存活的对象复制到另一块。清理用完的内存。 优点 无空间碎片，直接移动指针分配即可 缺点 空间浪费，内存缩小为原先的一半 优化 Appel式回收，将新生代分为一块较大的Eden空间和两块Survivor，每次分配内存只使用Eden和其中一块Survivor，发生垃圾收集时，将Eden和Suvivor中仍然存活的对象一次性复制到另外一块Survivor空间。然后直接清理掉Eden和已经使用过的。默认内存大小比例8:1:1。 如果存活的对象超过10%，这些对象会通过分配担保机制直接进入老年代。 标记-整理算法 标记存活的对象，移动到首部。 移动对象必须全程暂停用户应用程序。 关注吞吐量时可以使用。 也可以采用标记-清除和标记-整理相结合的方式，首先用标记-清除当碎片情况无法忍受时再用标记-整理来解决。 HotSpot实现细节 上述部分介绍的都是理论部分，现在结合实际的虚拟机实现来进行分析。 Todo 经典垃圾收集器 Serial收集器 新生代收集器 采用标记复制算法 最基础、历史最悠久的收集器。 单线程收集器且进行垃圾收集时，必须暂停其他所有工作线程。 额外内存消耗最小的 能与CMS一起使用 ParNew收集器 新生代收集器 使用标记复制算法 Serial的多线程版本 能与CMS一起使用 Parallel Scavenge收集器 新生代收集器 基于标记复制算法 并行收集 尽可能缩短用户线程停顿时间 吞吐量优先收集器 可以与PS MarkSweep、Serial Old、ParallelOld搭配 三个参数 最大垃圾收集停顿时间：-XX:MaxGCPauseMillis 吞吐量大小：-XX:GCTimeRatio 自适应的调节策略：-XX：+UseAdaptiveSizePolicy Serial Old收集器 老年代收集器 Serial收集器的老年代版本 单线程收集器 与Parallel Scavenge搭配使用，其实是PS MarkSweep收集器，但是实现几乎一样（选择一） 作为CMS收集器失败后的后背预案，并发收集发生Concurrent Mode Failure时使用（选择二） Parallel Old收集器 老年代收集器 Parallel Scavenge的老年代版本 CMS（Concurrent Mark Sweep）收集器（重要） 老年代收集器 并发收集、停顿时间短 基于标记清除算法 可以与Serial和Parnew组合 四个步骤 初始标记 并发标记 重新标记 并发清除 初始标记和重新标记仍然需要Stop The World。 初始标记标记一下GC Roots能直接关联到的对象 并发标记阶段就是从GC Roots能直接关联对象开始遍历整个对象的多城。不需要停止用户线程 重新标记修正并发标记阶段用户程序运行导致的变动（停顿时间比初始标记阶段稍长） 并发阶段，清理删除标记阶段判断已经死亡的对象，可以与用户线程并发进行 三个缺点 对处理器资源非常敏感（并发阶段会占用一部分CPU） 无法处理浮动垃圾，CMS的并发标记和并发清理阶段，用户程序在继续运行，可能会产生新的垃圾。可能出现Concurrent Mode Failure导致一次完全Stop The World的Full GC产生（这时使用Serial Old收集器进行收集）。为了防止该情况可将CMS开始GC的阈值设低一些。 基于标记清除算法，会有大量空间碎片。而在无法存放大对象时会触发Full GC。所以设置了碎片整理的参数。 Garbage First收集器（重要） 收集器面向局部收集 基于Region的内存布局 可预测的停顿时间模型 之前的垃圾收集器垃圾回收的范围一般是整个新生代、老年代或者整个Java堆。而G1收集并不区分，而是把Java堆划分为多个大小相等的独立区域，每个区域可以是新生代的Eden、Survivor或者是老年代。收集器对不同的Region采用不同的策略去处理。 Region中还有一类特殊的Humongous区域，专门用来存储大对象。 Region大小通过参数-XX:G1HeapRegionSize设定，范围为1MB～32MB，且为2的整数次幂。超过Region一半大小就会被判定为大对象。 对于超过了一个Region的大对象，会被存放到N个连续的Humongous Region中。G1把Humongous Region作为老年代一部分来看待。 Region作为回收的最小单元，可以让G1跟踪每个Region中垃圾的价值大小。根据回收所获得的空间大小和回收所需时间的经验，在后台维护一个优先级列表。根据设定的收集停顿时间，优先处理回收价值收益最大的Region。 步骤 初始标记 并发标记 最终标记 筛选回收 将一部分Region存活的对象复制到空的Regio中，再清理掉Region的全部空间。 Shenandoah收集器 To do ZGC收集器 To do By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/4.虚拟机性能监控故障定位.html":{"url":"Java/Java虚拟机/4.虚拟机性能监控故障定位.html","title":"虚拟机性能监控、故障定位","keywords":"","body":"虚拟机性能监控故障定位 故障处理工具 jps:虚拟机进程查看工具 列出正在运行的虚拟机进程，并显示出虚拟机执行主类以及这些进程的本地虚拟机唯一ID。 jstat:虚拟机统计信息监视工具 jstat可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。 定位虚拟机性能的常用工具。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/5.虚拟机调优.html":{"url":"Java/Java虚拟机/5.虚拟机调优.html","title":"虚拟机调优","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/6.类文件结构.html":{"url":"Java/Java虚拟机/6.类文件结构.html","title":"类文件结构","keywords":"","body":"类文件结构 概述 不同的操作系统对应的JVM支持统一的程序存储格式、字节码，使得Java可以运行是与平台无关的(平台无关性)。 实现无关性的基础是虚拟机和字节码存储结构。Java虚拟机只跟Class这种特定的二进制文件关联。而且上层的语言可以是任意的语言，只要编译出符合规范的Class文件(语言无关性)。 Class类文件的结构 Class类文件是一组以8个字节为基础单位的二进制流。 如果需要8个字节以上空间的数据项时，会按照高位在前的方式分割成若干个8字节。 只存在\"无符号数\"和\"表\" 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count-1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fileds fields_count u2 method_count 1 method_info methods method_count u2 attributes_count 1 attribute_info attributes attributes_count magic(魔数)与Class文件的版本 每个Class文件的开头4个字节为魔数。唯一作用是确定这个文件是否为能被虚拟机接受的Class文件 Class文件的魔数为0xCAFFVABABE 后面四个字节(minor_version和major_version)分别为次版本号和主版本号。高版本能兼容低版本，但不能运行后续版本的Class文件。 常量池 紧接着上述部分是常量池的入口。 常量池通常是占用空间最大的部分。 常量池的入口放置constant_pool_count，代表常量池容量计数值。容量计数从1开始，而不是0。0代表没有常量。 在类文件结构中只有常量池的计数是从1开始的。 常量池主要存放两大类常量：字面量和符号引用。 字面量一般是指文本字符串，被生命为final的常量值。 符号引用主要包括被模块导出或者开放的包，类和接口的全限定名，字段的名称和描述符，方法句柄和方法类型，动态调用点和动态常量。 constant_pool表结构的第一位是u1类型的标识位。代表当前变量属于哪种类型。 常量往往有两种，有可能直接就在结构中。类和接口的限定名往往指向另一个常量名。 访问标志 常量池后的2个字节代表访问标志，比如：这个Class是类还是接口，是否定义为public类型，是否为abstart，是类的话是否为final。 类索引、父类索引与接口索引集合 类索引和父类索引都是一个u2类型的数据，由于Java可以实现多个接口，因此接口索引是一个u2类型的集合。 Class文件由这三项来确认类型的继承关系。 除了java.lang.Object外，所有的Java类的父类索引都不为0。 接口索引集合，入口为u2类型的计数器，表示容量。如果没有实现接口，则计数器为0。后面的索引表不占用任何字节。 字段表集合 用于描述接口或者类中生命的变量。 字段包含的修饰符有 字段作用域（public、private、protected） 实例变量还是类变量（static修饰） 是否可以被修改（final） 并发可见性（volatile强制从主内存读写） 能否被序列化（transient修饰符） 字段数据类型（基本类型、对象、数组） 字段名称 方法表集合 与字段表类似 依次包括访问标志、名称索引、描述符索引、属性表集合。 方法表中的Java代码，编译成字节码指令之后存放在方法属性表中名称为Code的属性里面。 Java中要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求与其有不同的特征签名。 特征签名指的是一个方法中各个参数在常量池中的字段符号引用的集合。因此返回的参数类型是不在其中的。 属性表集合 Class文件、字段表、方法表都可以携带自己的属性表集合，用以描述某些场景特有的信息。 各种属性Todo... 字节码指令 Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码）以及后续0个或者多个操作数构成。 Java面向操作数栈，因此大多数指令都不包含操作数。 参数放在操作数栈中。（类似操作系统中的栈寻址） 操作码长度为一个字节（0～255） 指令的加载存储执行Todo... By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/7.虚拟机类加载机制.html":{"url":"Java/Java虚拟机/7.虚拟机类加载机制.html","title":"虚拟机加载机制","keywords":"","body":"虚拟机类加载机制 概述 Class文件要被加载到虚拟机之中才能被运行和使用。 Java虚拟机把Class文件加载到内存，然后进行数据校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 类型的加载、连接和初始化都是在程序运行期间完成的。 即运行期动态加载和动态连接。 类加载时机 加载、验证、准备、初始化和卸载这五个顺序是确认的。 解析可以在初始化之后进行。 以下6种情况必须立即对类做初始化（对类型的主动引用）。 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先出发初始化 使用new实例化对象 读取或设置一个类型的静态字段（被final修饰、已在编译器放入常量池的静态字段除外） 调用类型的静态方法 使用java.lang.reflect方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化 初始化类的时候，如果父类还没有初始化，则需要先触发父类的初始化 虚拟机启动时，主要指定包含main()一个方法执行，虚拟机会先初始化这个类 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄。 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法），如果有这个接口的视实现类发生了初始化，那该接口要在其之前被初始化。 被动引用的几个例子 通过子类访问父类的静态变量 只会触发父类的初始化。 XClass[] xcls = new XClass[10]并不会触发初始化 但是会触发L+[限定名]类的初始化，代表一维数组。 访问类的静态常量不会触发 类的常量会直接存储在NotInitialization的常量池中 接口与类不同的地方是接口初始化时，并不要求其父接口完成了初始化，只有使用到父接口时才会初始化。 类加载的过程 加载、验证、准备、解析和初始化 加载 完成以下三个步骤 通过一个类的全限定名来获取定义此类的二进制字节流 从ZIP压缩包获取，JAR、EAR、WAR 从网络获取，比如Web Applet 运行时动态生成，动态代理技术 由其他文件生成，JSP生成Class文件 从数据库中读取 从加密文件中获取 将字节流代表的静态存储结构转化成方法区的运行时数据结构 在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 加载阶段获取类的二进制字节流的动作是开发人员可以进行操作的阶段。可以使用内置的类加载器，也可以使用自定义的类加载器（重写一个类加载器的findClass()或者loadClass()方法）。 对于数组类而言，数组类本身不通过类加载器创建，是由Java虚拟机动态构造出来。 类加载器 双亲委派 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/8.虚拟机字节码执行引擎.html":{"url":"Java/Java虚拟机/8.虚拟机字节码执行引擎.html","title":"虚拟机字节码执行引擎","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/9.前端编译优化.html":{"url":"Java/Java虚拟机/9.前端编译优化.html","title":"前端编译优化","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/10.后端编译优化.html":{"url":"Java/Java虚拟机/10.后端编译优化.html","title":"后端编译优化","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/11.Java内存模型与线程.html":{"url":"Java/Java虚拟机/11.Java内存模型与线程.html","title":"Java内存模型与线程","keywords":"","body":"Java内存模型与线程 概述 Java虚拟机如何实现多线程、多线程之间由于共享和竞争数据而导致的一系列问题及解决方案。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Java/Java虚拟机/12.线程安全与锁优化.html":{"url":"Java/Java虚拟机/12.线程安全与锁优化.html","title":"线程安全与锁优化","keywords":"","body":"线程安全与锁优化 锁消除 如果经过逃逸分析后，JVM发现某个对应的锁没有竞争，则会对其进行优化。 可偏向状态 计算过HashCode无法再进入偏向锁状态，会存储HashCode。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Web/":{"url":"Web/","title":"Web","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Web/HTTP.html":{"url":"Web/HTTP.html","title":"HTTP、HTTPS、HTTP2","keywords":"","body":"HTTP HTTP URI包含URL和URN 统一资源标识符 统一资源定位符 统一资源名称 HTTP状态码 服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational （信息性状态码） 2XX Success （成功状态码） 3XX Redirection （重定向状态码） 4XX Client Error （客户端错误状态码） 5XX Server Error （服务器错误状态码） HTTPS HTTP存在以下问题 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 根据OSI7层模型，SSL应该属于会话层。 HTTPS流程 HTTPS 需要使用一套 CA 数字证书，证书内会附带一个公钥 Pub，而与之对应的私钥 Private 保留在服务端不公开。 服务端收到请求，返回配置好的包含公钥 Pub 的证书给客户端。 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示 HTTPS 警告信息，如果通过则继续。 客户端生成一个用于对称加密的随机 Key，并用证书内的公钥 Pub 进行加密，发送给服务端。 服务端收到随机 Key 的密文，使用与公钥 Pub 配对的私钥 Private 进行解密，得到客户端真正想发送的随机 Key。 服务端使用客户端发送过来的随机 Key 对要传输的 HTTP 数据进行对称加密，将密文返回客户端。 客户端使用随机 Key 对称解密密文，得到 HTTP 数据明文。 后续 HTTPS 请求使用之前交换好的随机 Key 进行对称加解密。 HTTPS与HTTP区别 HTTP使用80端口，HTTPS使用443端口 存在加密解密过程，速度会比HTTP稍慢 HTTP2 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Web/Spring.html":{"url":"Web/Spring.html","title":"Spring","keywords":"","body":"Spring IOC Spring AOP 面向切面编程 定义 我们在某个地方定义通用功能，然后使用声明的方式定义这个类要以何种方式使用。而不去修改受影响的类。 横切点可以写成一个类，这些类称为切面。 解决的问题/好处 某个功能需要在很多地方用到，但是不想在每个地方都显式去调用他。 关注点可以集中在一个地方，方便修改 服务模块更加简洁，通用功能写到了切面中 底层实现 常用场景 登陆拦截功能 日志功能 Spring bean的生命周期 Spring事务 Spring 隔离级别 Spring三种注入方式 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Web/Spring注解.html":{"url":"Web/Spring注解.html","title":"Spring注解","keywords":"","body":"Spring注解 @Resource与@Autowired区别 @Autowired是Spring的注解，@Resource是JDK的注解 @Autowired默认按类型装配（byType），@Resource默认是按名称装配（byName） @Bean注解 使用@Bean注解的原因，Component , @Repository , @ Controller , @Service这些只能使用在自己编写的类中。而第三方Jar包中的类要加入到IOC容器中可以使用@Bean。 class test{ @Bean public DataSource dataSource(){ return new DataSource(); } } By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Web/SpringBoot.html":{"url":"Web/SpringBoot.html","title":"SpringBoot","keywords":"","body":"SpringBoot 来源链接 https://www.cnblogs.com/xuwujing/p/11184162.html 与Spring的差别 @Transaction注解 声明式事务处理。建立在AOP之上，在目标方法之前创建或者加入一个事务，执行完毕后提交事务，若失败则回滚事务。 事务隔离级别 隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播行为 所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。 事务回滚规则 默认配置下，只有在抛出的异常为unchecked异常时才会回滚，抛出的异常为RuntimeException的子类或者Errors也会导致回滚。 事务常用配置 readOnly：该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：@Transactional(readOnly=true)； rollbackFor： 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})； rollbackForClassName： 该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：指定单一异常类名称@Transactional(rollbackForClassName=”RuntimeException”)指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”,”Exception”})。 noRollbackFor：该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如：指定单一异常类：@Transactional(noRollbackFor=RuntimeException.class)指定多个异常类：@Transactional(noRollbackFor={RuntimeException.class, Exception.class})。 noRollbackForClassName：该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如：指定单一异常类名称：@Transactional(noRollbackForClassName=”RuntimeException”)指定多个异常类名称：@Transactional(noRollbackForClassName={“RuntimeException”,”Exception”})。 propagation ： 该属性用于设置事务的传播行为。例如：@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true)。 isolation：该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置。 timeout：该属性用于设置事务的超时秒数，默认值为-1表示永不超时。 @Transaction用法 可以作用在接口、类、类方法上。 事务失效场景 @Transactional注解应用在非public 修饰的方法上，Transactional将会失效 @Transactional注解属性 propagation 设置为不回滚 @Transactional注解属性rollbackFor设置中没有设置对应的Exception类型 类中未注解的方法A去掉用注解的B，@Transactional不生效。只有方法被类意外的代码调用，才会由Spring生成的代理对象来管理 catch掉异常不抛出，@Transactional失效。 数据库引擎不支持事务，比如MyISAM By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Web/Servlet.html":{"url":"Web/Servlet.html","title":"Servlet","keywords":"","body":"Servlet Java Servlet是运行在Web服务器上或应用服务器上的程序。 Servlet生命周期 Servlet调用init()方法来初始化 Servlet调用service()方法来处理客户端的请求 Servlet调用destroy()方法终止 最后Servet是由JVM的垃圾收集器进行回收的 init()方法 init方法被设计只调用一次。在第一次创建Servlet的时候被调用，在后续每次用户请求 时不再被调用。 Servlet创建于用户第一次调用对应于Servlet的URL时，也可以指定在第一次启动时就被加载。 当用户调用一个Servlet时，就会创建一个Servlet实例，每一个用户请求都会产生一个新的线程。适当的时候移交给doGet或者doPost方法。init()方法简单的创建或者加载一些数据，这些数据在Servlet的整个生命周期中都会被使用。 service()方法 service()方法是实际执行任务的主要方法。 每次服务器接收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。 service()方法检查HTTP（GET、POST、PUT、DELETE等），并在适当的时候调用对应的方法。 doGet()方法 doPost()方法 destroy()方法 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Web/Mybatis.html":{"url":"Web/Mybatis.html","title":"Mybatis","keywords":"","body":"Mybatis mybatits # 和 $ 的区别 {}会被解析为？，而${}则是进行直接的字符替换 能使用 #{ } 的地方就用 #{ }，预编译相同语句可以重复利用，${}可能会存在sql注入问题 表名中只可以使用${} mybatis的mapper方法能否重载，为什么不能 不能重载，因为需要通过接口名+方法名唯一定位一个MappedStatement。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DesignPattern/":{"url":"DesignPattern/","title":"设计模式","keywords":"","body":"设计模式示例 Design Pattern 设计原则 单一职责原则(Single Responsibility Principle) 一个类应该只有一个职责，尽量做到一个类只有一个职责，可以使得对象之间的依赖减少，减少耦合度。 里氏替换原则(Liskov Substitution Principle) 假设有父类A和子类B，假设以父类定义的程序在换成B后都可以正常运行。(体现这个原则策略模式、组合模式、代理模式) 依赖倒置原则(Dependence Inversion Principle) 模块间的依赖通过抽象发生，实现类之间不发生之间的依赖关系，其依赖关系是通过接口或抽象类产生;接口或抽象类不依赖于实现类;实现类依赖于接口或抽象类 接口隔离原则(Interface Segregation Principle) 1.实例接口(实际类) 2.类接口(intetface定义的类)。一个接口应该设计的小一点。可以实现多个接口，尽量使得接口功能小，使得实现接口时不带不需要的接口。 迪米特法则(Law of Demeter) 尽量不跟“陌生人”说话，不产生联系。可以通过中间对象进行通信。 开闭原则(Open-Closed Principle) 一个软件实体应该对扩展开放，对修改关闭。应该在不修改原来代码的情况下进行扩展。 普通23种 创建型模式 单例模式 工厂模式 抽象工厂模式 建造者模式 原型模式 结构性模式 代理模式 装饰模式 适配器模式 组合模式 桥梁模式 外观模式 享元模式 行为型模式 模板方法模式 命令模式 责任链模式 策略模式 迭代器模式 中介者模式 观察者模式 备忘录模式 访问者模式 状态模式 解释器模式 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DesignPattern/Creational.html":{"url":"DesignPattern/Creational.html","title":"创建型","keywords":"","body":"创建型模式 单例模式 简介 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象 主要解决 一个全局使用的类频繁地创建与销毁 优点 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存） 避免对资源的多重占用（比如写文件操作） 缺点 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化 单例模式有众多种类 懒汉式（线程不安全） /** * * Lazy初始化 * 多线程不安全 * * 不支持多线程，因为没有加锁。再多线程模式下可能会产生多个instance * */ public class SingletonLazyNotThreadSafe { private static SingletonLazyNotThreadSafe instance; private SingletonLazyNotThreadSafe(){} public static SingletonLazyNotThreadSafe getInstance() { if (instance == null) { instance = new SingletonLazyNotThreadSafe(); } return instance; } } 懒汉式（线程安全） /** * * Lazy初始化 * * 多线程安全 * * 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 * 优点：第一次调用才初始化，避免内存浪费。 * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 * */ public class SingletonLazyThreadSafe { private static SingletonLazyThreadSafe instance; private SingletonLazyThreadSafe() {} public static synchronized SingletonLazyThreadSafe getInstance() { if (instance == null) { instance = new SingletonLazyThreadSafe(); } return instance; } } 饿汉式 /** * 多线程安全 * * 种方式比较常用，但容易产生垃圾对象。 * 优点：没有加锁，执行效率会提高。 * 缺点：类加载时就初始化，浪费内存。 * 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化， * 虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 * */ public class SingletonHungry { private static SingletonHungry instance = new SingletonHungry(); private SingletonHungry() {} public static SingletonHungry getInstance() { return instance; } } DoubleCheckLock（重要） /** * Lazy初始化 * * 线程安全 * * 使用双锁机制，安全且在多线程情况下能保持高性能 * */ public class SingletonDoubleCheckedLocking { private volatile static SingletonDoubleCheckedLocking singleton; private SingletonDoubleCheckedLocking () {} public static SingletonDoubleCheckedLocking getSingleton() { if (singleton == null) { synchronized (SingletonDoubleCheckedLocking.class) { if (singleton == null) { singleton = new SingletonDoubleCheckedLocking(); } } } return singleton; } } 静态内部类实现 /** * Lazy初始化 * * 线程安全 * * 这种方式能达到双检锁方式一样的功效，但实现更简单。 * 对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 * * 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程， * * 它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果） * ，而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时， * 才会显式装载 SingletonHolder 类，从而实例化 instance。 * * 想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化， * 因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比饿汉式就显得很合理。 * */ public class SingletonStaticInnerClasses { private static class SingletonStaticInnerClassesHolder { private static final SingletonStaticInnerClasses INSTANCE = new SingletonStaticInnerClasses(); } private SingletonStaticInnerClasses () {} public static final SingletonStaticInnerClasses getInstance() { return SingletonStaticInnerClassesHolder.INSTANCE; } } 工厂模式 享元模式 简介 享元模式（Flyweight Pattern）主要用于减少创建对象的数量。用来减少内存占用和提高性能。 尝试重用已经存在的对象，若未找到，则创建新对象。 主要解决 尝试直接返回已有的对象，避免对象的重新创建。 优点 减少对象创建，减少内存的浪费 缺点 提高了系统复杂度。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DesignPattern/Structural.html":{"url":"DesignPattern/Structural.html","title":"结构型","keywords":"","body":"结构型模式 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DesignPattern/Behavioral.html":{"url":"DesignPattern/Behavioral.html","title":"行为型","keywords":"","body":"行为型模式 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"LinuxKernel/":{"url":"LinuxKernel/","title":"Linux内核","keywords":"","body":"Linux常见问题 零拷贝 零复制（英语：Zero-copy；也译零拷贝）技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。 Java输入流可以通过java.nio.channels支持零复制。FileChannel的transferTo()方法也可以支持零复制（如果底层操作系统支持）。 操作系统某些组件（例如驱动程序、文件系统和网络协议栈）若采用零复制技术，则能极大地增强了特定应用程序的性能，并更有效地利用系统资源。通过使CPU得以完成其他而非将机器中的数据复制到另一处的任务，性能也得到了增强。另外，零复制操作减少了在用户空间与内核空间之间切换模式的次数。 举例来说，如果要读取一个文件并通过网络发送它，传统方式下每个读/写周期都需要复制两次数据和切换两次上下文，而数据的复制都需要依靠CPU。通过零复制技术完成相同的操作，上下文切换减少到两次，并且不需要CPU复制数据。 零复制协议对于网络链路容量接近或超过CPU处理能力的高速网络尤为重要。在这种网络下，CPU几乎将所有时间都花在复制要传送的数据上，因此将成为使通信速率低于链路容量的瓶颈。 减少了数据在内核空间和用户空间之间频繁的传输。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"LinuxKernel/Linux中断和异常.html":{"url":"LinuxKernel/Linux中断和异常.html","title":"Linux中断和异常","keywords":"","body":"Linux中断 为什么会有中断 内核的主要功能就是处理外设的IO 处理器的速度一般比外设快很多 加入中断后可以处理其他任务，完成后CPU才处理外设IO 轮询方式效率低 查看系统中断信息 cat /proc/interrupts 中断和异常 中断（广义）会改变处理器执行指令的顺序，通常与CPU芯片内部或外部硬件电路产生的电信号相对应，用\"中断信号\"来统称这两类类型的中断。 中断----异步 由硬件随机产生 异常----同步 在（特殊的或出错的）指令执行时由CPU控制单元产生 中断信用的作用 中断信号处理的一般原则 I/O设备如何引起CPU中断 x86 CPU如何在硬件级别处理中断 Linux内核中软件级中断处理及其数据结构 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DataBase/":{"url":"DataBase/","title":"数据库","keywords":"","body":"数据库 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DataBase/数据库基本原理.html":{"url":"DataBase/数据库基本原理.html","title":"数据库基本原理","keywords":"","body":"数据库基本原理 数据库基本原理 关系数据库设计原理 函数依赖 记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。 如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。 对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。 对于 A->B，B->C，则 A->C 是一个传递函数依赖。 异常 以下的学生课程关系的函数依赖为 {Sno, Cname} -> {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。 不符合范式的关系，会产生很多异常，主要有以下四种异常： 冗余数据：例如 学生-2 出现了两次。 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。 范式 范式理论是为了解决以上提到四种异常。 高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。 第一范式（1NF） 强调的是列的原子性，即列不能够再分成其他几列。 考虑这样一个表：【联系人】（姓名，性别，电话） 如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）。 第二范式（2NF） 非主属性完全依赖于主关键字 学生名 课程名 成绩 成绩由学生名和课程名决定 第三范式 (3NF) 非主属性不传递函数依赖于键码。 学生 学院 院长名 存在传递依赖 分成学生、学院 学院、院长名 数据冗余 如果院长更换 需要修改很多 ER图 Entity-Relationship，有三个组成部分：实体、属性、联系。 用来进行关系型数据库系统的概念设计。 包含一对一，一对多，多对多三种。 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B； 如果是一对一，画两个带箭头的线段； 如果是多对多，画两个不带箭头的线段。 Join INNER JOIN和JOIN LEFT JOIN RIGHT JOIN FULL JOIN By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DataBase/MySQL.html":{"url":"DataBase/MySQL.html","title":"MySQL","keywords":"","body":"MySQL 参考资料 MySQL 是怎样运行的：从根儿上理解 MySQL 高性能MySQL（第三版） 基本介绍 MySQL是一款应用广泛的关系型数据库 mysql引擎 InnoDB（默认） MyISAM 其实有更多，但是主要是这两种。可以通过SHOW ENGINES;查看。 创建时可以指定，不指定则为默认引擎 SQL CREATE TABLE 表名( 建表字段; ) ENGINE = 存储引擎名称; InnoDB和MyISAM区别 InnoDB支持事务，支持行级锁和外键（重要），MyISAM只支持表锁 InnoDB 是聚集索引，MyISAM 是非聚集索引。聚集索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。 InnoDB 不保存表的数据行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用变量保存了表的行数。 索引 使用索引的优缺点 优点 大大缩短查询的时间 缺点 创建和维护索引需要时间 索引需要空间去存 InnoDB引擎采用B+树来实现 B+树优点 B+树的磁盘读写代价更低 B+树的数据信息遍历更加方便 B+树的查询效率更加稳定 索引的类型 事务 ACID实现 原子性 通过InnoDB undo log 持久性 通过InnoDB redo log 隔离性 隔离级别与锁机制 Undo日志 Redo日志 隔离级别 默认级别 可重复读 隔离级别表格 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 可能 可能 可能 READ COMMITTED 不可能 可能 可能 REPEATABLE READ 不可能 不可能 可能 SERIALIZABLE 不可能 不可能 不可能 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。 MVCC ReadView readview用来实现读已提交和可重复读 两个区别是通过生成readview的时机来区分的。 读已提交每次读都会重新生成ReadView 可重复读在第一次读的时候生成ReadView 锁机制 分库分表 常用组件 Mybaits JPA（笔者不喜欢这种组件） MySQL实践 MySQL处理的一些坑 时间字段的表示问题 使用时间戳 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DataBase/Redis.html":{"url":"DataBase/Redis.html","title":"Redis","keywords":"","body":"Redis 1.思维导图 2.redis基本命令 Redis命令 RedisAPI RedisAPI 3.Redis常见数据结构 4.Redis单线程模型详解 5.Redis数据策略 redis缓存数据过期策略 redis数据淘汰策略 淘汰策略 redis持久化机制 RDB和AOF如果同时配置，默认加载AOF的配置文件。 redis缓存策略 6.Redis使用常见问题 1.缓存雪崩 大量key同时过期，导致数据库短时间接受大量请求。 针对 Redis 服务不可用的情况 使用Redis 集群，避免单机问题 限流操作，避免同时大量的请求同时落到数据库 针对热点缓存失效的情况： 随机设置缓存的失效时间 缓存永不失效 2.缓存击穿 大量key根本不存在，导致请求落在了数据库上 解决方法 缓存无效key 布隆过滤器 3.缓存与数据库一致性问题 7.Redis中常见的第三方库 8.redis集群 9.Redis分布式锁 1.使用setnx+expire实现 问题 setnx和expire不具有原子性，容易出错 解决方法 lua脚本，同时包含setnx和expire两条指令 2.使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 EX seconds: 设定过期时间，单位为秒 PX milliseconds: 设定过期时间，单位为毫秒 NX: 仅当key不存在时设置值 XX: 仅当key存在时设置值 value值最好具有唯一性。可以使用UUID等方式进行设置。 释放锁时判断一下value值再释放。 分布式情况下可能会出问题。 比如有节点A和节点B，节点A挂掉，尚未同步到节点B。这时出错。 3.redlock 具体步骤 假设有5个redis节点 获取当前Unix时间，以毫秒为单位 依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁 当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等 客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的Redis节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要 如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁，无论Redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题 分布式锁 10.Redis事务 11.Redis Stream(消息队列) By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DataBase/Hbase.html":{"url":"DataBase/Hbase.html","title":"Hbase","keywords":"","body":"Hbase By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"MessageQueue/":{"url":"MessageQueue/","title":"消息队列","keywords":"","body":"消息队列 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"MessageQueue/Kafka.html":{"url":"MessageQueue/Kafka.html","title":"Kafka","keywords":"","body":"Kafka Kafka发展史 Kafka部署 producer开发 consumer开发 Kafka设计原理 broker端设计架构 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"ContainerTechnology/":{"url":"ContainerTechnology/","title":"容器技术","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"ContainerTechnology/Docker.html":{"url":"ContainerTechnology/Docker.html","title":"Docker","keywords":"","body":"Docker Docker简介 来自维基百科的简介 Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付应用、运行应用。 Docker允许用户将基础设施中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。 Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。 Docker 利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间，来创建独立的容器。这可以在单一Linux实体下运作，避免引导一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、存储器、block I/O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由libvirt的LXC与systemd - nspawn提供界面的基础上，开始包括libcontainer库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施， Docker镜像操作 Docker容器操作 Docker安装常用软件 Docker挂载Volume By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"ContainerTechnology/Kubernetes.html":{"url":"ContainerTechnology/Kubernetes.html","title":"Kubernetes","keywords":"","body":"Kubernetes Kubernetes简介 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DistributedSystem/":{"url":"DistributedSystem/","title":"分布式","keywords":"","body":"分布式系统 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DistributedSystem/IntroductionToDistributedSystem.html":{"url":"DistributedSystem/IntroductionToDistributedSystem.html","title":"分布式系统简介","keywords":"","body":"分布式系统简介 ACID、CAP、BASE理论 ACID 原子性 一致性 隔离性 持久性 CAP理论： C.一致性 A.可用性 P.分区容错性 往往无法同时满足 BASE理论: Basically Available（基本可用） 在出现不可预知故障时候，允许使用部分可用性 Soft state（软状态） 允许系统中的数据存在中间状态，允许数据同步存在时延 Eventually consistent（最终一致性） 系统中所有的数据副本，经过一段时间的同步后，最终能够达到一个一致的状态（不同于强一致性）。 2PC To do 3PC To do Paxos To do 一致性Hash 分布式锁 Redis实现 1.使用setnx+expire实现 问题 setnx和expire不具有原子性，容易出错 解决方法 lua脚本，同时包含setnx和expire两条指令 2.使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 EX seconds: 设定过期时间，单位为秒 PX milliseconds: 设定过期时间，单位为毫秒 NX: 仅当key不存在时设置值 XX: 仅当key存在时设置值 value值最好具有唯一性。可以使用UUID等方式进行设置。 释放锁时判断一下value值再释放。 分布式情况下可能会出问题。 比如有节点A和节点B，节点A挂掉，尚未同步到节点B。这时出错。 redlock 具体步骤 假设有5个redis节点 获取当前Unix时间，以毫秒为单位 依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁 当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等 客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的Redis节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要 如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁，无论Redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题 分布式锁 ZooKeeper实现 ZooKeeper实现 假设有客户端A和客户端B竞争一把锁lock 获取锁就是在lock节点下创建一个xxxx1节点，比如A创建了xxxx1获取到了锁，这时候客户端B来获取锁，创建xxxx2节点，发现自己并不是第一个节点。就去坚挺xxxxx1节点（ZooKeeper特性）。客户端A处理好后，删除了节点，这时客户端B会收到ZooKeeper的提醒。每次加锁都是监听上一个节点。 如果正在获取锁的节点宕机，ZooKeeper能感知到，会把它的节点进行删除操作。 使用ZooKeeper和Redis的区别 Redis获取锁的方式简单粗暴，获取会不断尝试获取锁，比较消耗性能。Zookeeper是提醒型。 Redis 的设计定位决定了数据不是强一致性的，可能会出现问题。锁的模型不够健壮。 即便使用 Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题严重依赖时钟，比如有些服务器时钟走的特别快，可能会出问题 现在使用Redis的情况比较多，因为Redis的性能好，ZooKeeper如果有较多的集群申请加锁、释放锁，压力会比较大。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"DistributedSystem/ZooKeeper.html":{"url":"DistributedSystem/ZooKeeper.html","title":"ZooKeeper","keywords":"","body":"ZooKeeper ZooKeeper简介 介绍 ZooKeeper是一个开源的分布式协调服务，是Google Chubby的开源实现。 设计目的是将复杂且容易出错的分布式一致性服务封装起来，提供简单易用的接口给开发者使用。 ZooKeeper使用共享树型的名字空间来相互协调。 树型空间由一系列ZNode的数据节点组成，类似于一个文件系统的层级结构。 ZooKeeper的全量数据均存储在内存中。 集群 Leader、Follower和Observer三种角色。 Leader是通过选举算法得到的。 Leader服务器可以提供读和写服务 Leader、Follower和Observer都能提供读服务 Observer只用来提升集群的读性能，不参与Leader选举，也不参与写操作的过半写成功策略。 数据节点（ZNode） ZooKeeper数据模型中的数据单元。 数据模型一棵树，路径由斜杠分割。类似树型文件系统。 /root/test Watcher Zookeeper允许用户在指定节点上注册一些Watcher，并且在特定事件触发的时候，ZooKeeper服务端会将事件通知到对应的客户端上。 ACL ZooKeeper定义了5种权限 CREATE：创建子节点的权限 READ：获取节点数据和子节点列表的权限 WRITE：更新节点数据的权限 DELETE：删除子节点的权限 ADMIN：设置节点ACL的权限 ZAB协议 ZooKeeper采用了一种被称为ZooKeeper Atomic Broadcast（ZAB，ZooKeeper原子消息广播协议）作为其数据一致性的核心算法。 ZooKeeper的核心流程：所有事务请求必须由一个全局唯一的服务器来协调处理。即Leader服务器将客户端的请求转换成一个提案，并且将提案发送给所有Follower服务器。之后等待Follower的回应，回应数超过半数，那么Leader服务器就会发送Commit消息，提交前一个Proposal。（Observer服务器不参与半数） ZAB主要流程可以分为两个部分 崩溃恢复 消息广播 崩溃恢复 崩溃恢复主要指的是Leader的重新选举过程。 消息广播 ZooKeeper部署 JavaAPI使用 应用场景 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"NettyandRPC/":{"url":"NettyandRPC/","title":"Netty和RPC","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"NettyandRPC/Netty.html":{"url":"NettyandRPC/Netty.html","title":"Netty","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"NettyandRPC/Dubbo.html":{"url":"NettyandRPC/Dubbo.html","title":"Dubbo","keywords":"","body":"Dubbo RPC RPC（Remote Procedure Call）远程过程调用 API与SPI API（Application Programming Interface） 大多数情况下，都是实现方来制定接口并完成对接口的不同实现，调用方仅仅依赖却无权选择不同实现。 SPI（Service Provider Interface） 而如果是调用方来制定接口，实现方来针对接口来实现不同的实现，调用方来选择自己需要的实现方。 架构 service层由业务自定义 各层说明： config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类 proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool 负载均衡 文档 Random LoadBalance(默认，基于权重的随机负载均衡机制) 简介 随机，按权重设计随机概率。 现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上。 缺点 调用次数少时可能会集中在某些服务器上。 LeastActive LoadBalance 简介 活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。除了最小活跃数，LeastActiveLoadBalance 在实现上还引入了权重值。所以准确的来说，LeastActiveLoadBalance 是基于加权最小活跃数算法实现的。举个例子说明一下，在一个服务提供者集群中，有两个性能优异的服务提供者。某一时刻它们的活跃数相同，此时 Dubbo 会根据它们的权重去分配请求，权重越大，获取到新请求的概率就越大。如果两个服务提供者权重相同，此时随机选择一个即可。 ConsistentHash LoadBalance 简介 一致性 Hash，相同参数的请求总是发到同一提供者。 挂掉了其中一台，会分到相近的节点 RoundRobin LoadBalance(基于权重的轮询负载均衡机制) 简介 在详细分析源码前，我们先来了解一下什么是加权轮询。这里从最简单的轮询开始讲起，所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器 A。这个过程就叫做轮询。轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景下。但现实情况下，我们并不能保证每台服务器性能均相近。如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务器 A、B、C 权重比为 5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Microservice/":{"url":"Microservice/","title":"微服务","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Microservice/SpringCloud/":{"url":"Microservice/SpringCloud/","title":"SpringCloud","keywords":"","body":" By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"InformationSecurity/":{"url":"InformationSecurity/","title":"信息安全","keywords":"","body":"信息安全与网络安全 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"InformationSecurity/信息安全.html":{"url":"InformationSecurity/信息安全.html","title":"信息安全","keywords":"","body":"信息安全 ARP协议问题 ARP协议的作用是什么。 主机广播IP寻找MAC地址，返回单播。 32位IP地址和48位MAC之间的转换。（广播询问，单播答复） 引入ARP缓存的功能是什么。 将这一映射关系保存在 ARP 缓存中，使得不必重复运行 ARP 协议。 ARP缓存中毒的攻击方法和效果是什么。 方法 因为 ARP 缓存中的映射表并不是一直不变的，主机会定期发送 ARP 请求来更新它的 ARP 映射表，利用这个机制，攻击者可以伪造 ARP 应答帧使得主机错误的更新自己的 ARP 映射表，这个过程就是 ARP 缓存中毒。 效果 要么使主机发送 MAC 帧到错误的 MAC 地址，导致数据被窃听；要么由于 MAC 地址不存在，导致主机无法访问实际的服务。 预防 小型网络 静态IP地址和静态ARP映射表。 大型网络 “端口安全” 功能是允许你强制使你的交换机在每个端口只允许 (IP地址对应的) 一个MAC地址通过。这个功能会阻止黑客改变他机器的MAC地址或试图映射多个MAC地址到他的机器上。 一般网络 ARP监视工具，比如ARPwatch，当有不正常的ARP通信时它会提醒你。 攻击前需要清除本机ARP缓存 arp -n #查看arp表 arp -d address #删除一个arp表项 arp -s address hw_addr #设置一个arp表项 -e为MAC地址，-i为被攻击主机的IP地址，netwox是一个发包工具 netwox 80 --eth \"00:00:00:00:00:00\" --ip \"192.168.224.134\" IP协议安全问题 为什么IP要进行分片？ 主要是因为硬件环境的MTU限制。一个IP报文最多可以达到65535的最大长度；但是网络硬件限制了帧的大小（以太网限制为1500字节）。 IP分片如何进行重组？ IDENT: 也即identifier，用于标识IP报文段的唯一标识符；具有同一IDENT的片段属于同一个IP报文； FRAGMENT OFFSET: 简称FO，指明当前片段在原始完整的IP报文中的位置（偏移）。该偏移的单位是8个字节。 FLAGS: bit 0：保留；bit 1：不分片；bit 2：更多分片。如果此位是1，那么说明不是最后一个分片，如果是0，说明是最后一个分片。 泪滴攻击（teardrop）的原理是什么？ 原理，在于构造两个分片。其中，第二个分片完全包含在第一个分片中。也即，第二个分片的FO大于第一个分片的FO，但是第二个分片的FO+ Len，都小于第一个分片最后一个字节的位置，也即第一个分片的FO+len。计算出end - offset为负数。 if (prev != NULL && offset end) // if there are overlapping fragments；offset是第二个分片的offset，小于前一分片的结尾，存在重叠 { i = prev->end - offset; //计算重叠的长度，保留前一分片的重叠部分 offset += i;/* ptr into datagram */ //移动到第二分片的非重叠内容，也即前一分片的结尾 ptr += i;/* ptr into fragment data */ // 指针移动到前一分片的结尾，然后拷贝第二分片的剩余内容 //advance to the end of the previous fragment fp->len = end - offset; // 计算接下来需要拷贝多少字节 ... } 攻击的成功，依赖于一种当分片发生重叠时，主机使用第一个分片来覆盖第二个分片的重叠内容。 防范：丢弃FO == 1片段；限制最小数据传输大小。 包过滤防火墙，通过过滤SYN包，防止外部链接。攻击者可以如何绕过这个过滤？ 利用微小碎片攻击。 第一个片段仅包含八个字节的数据（最小片段大小）。在TCP的情况下，这足以包含源和目标端口号，但它将强制TCP标志字段进入第二个片段。 尝试删除连接请求的过滤器（具有SYN = 1和ACK = 0的TCP数据报）将无法在第一个八位字节中测试这些标志，并且通常会在后续片段中忽略它们。 防止方法：限制通过的片段的大小。即第一个片段足够大以包含所有必需的头信息（直接方法）。碰到FO=1的包，直接丢弃。（间接方法） 重叠碎片攻击 攻击者可以构造一系列数据包，其中，最低（零偏移）片段将包含无害数据（从而通过管理数据包过滤器传递），并且其中一些后续数据包具有非零offset会重叠TCP头信息（例如目标端口）并导致它被修改。第二个数据包将被通过大多数的过滤器通过，因为它没有零片段偏移量。如果接收主机具有阻止新数据覆盖先前接收的数据的重组算法，我们可以首先发送片段2，然后发送片段1，并完成相同的成功攻击。 防治方法： 如果FO == 1 并且 PROTOCOL == TCP DROP PACKET ICMP协议安全 什么是SMURF攻击？如何防止？ Smurf攻击是一种分布式拒绝服务攻击，其中使用IP广播地址将具有预期受害者的欺骗源IP的大量互联网控制消息协议（ICMP）分组广播到计算机网络。 默认情况下，网络上的大多数设备都会通过向源IP地址发送回复来对此做出响应。 如果网络上接收和响应这些数据包的机器数量非常大，受害者的计算机将忙于处理ping回复包。 这可能会使受害者的计算机变慢，无法继续工作。 预防：（1）配置各个主机和路由器不响应ICMP请求或广播；（2）配置路由器不转发定向到广播地址的数据包。 什么是ICMP重定向攻击？如何防止？ 主机假设路由器的信息更权威，当主机ICMP重定向功能开启时，攻击者冒充默认网关，给目标主机发送ICMP重定向报文，报文中的重定向地址为虚假不可达的、网络不通的或攻击者主机的地址。当目的主机收到ICMP重定向报文后，就会对路由表进行添加、修改，将重定向的IP地址设置为指定目标之间的通信网关IP地址，使得通信失败或者拦截通信数据包。 预防： 关闭ICMP重定向，或者过滤ICMP报文 ICMP重定向攻击，-f为过滤器，-g为重定向的网关IP，-i为原来的网关IP $ sudo netwox 86 -f \"host ${被攻击主机ip地址}\" -g \"${新指定的网关ip地址}\" -i \"${当前网关ip地址}\" 其他 TCP协议安全 什么是SYN flooding攻击？效果是什么？如何防止？ SYN flooding之前也讨论过，发生这种攻击的原因是因为TCP三次握手过程中的一个设计。当应用开放了一个TCP端口后，该端口就处于侦听状态，不停地监视发到该端口的Syn报文，一旦接收到Syn报文，就需要为即将建立的TCP连接分配TCB（Transmission Control Block），通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至达到1300个字节；并且进入半开连接（half-opening）状态，也即收到SYN包而还未收到ACK包时的连接状态。操作系统实现的最多可开启的半开连接个数是一定的，譬如512，而受到内存的限制，可能还达不到这个数字。如果半开连接的个数过多，就会消耗掉可用的内存，使得新的正常的连接请求不能被处理。 效果：如果半开连接的个数过多，就会消耗掉可用的内存，使得新的正常的连接请求不能被处理或者处理的非常慢。 预防： （1）SYN Cache。每次来了SYN包，那么就在SYN Cache队列中生成一个项，保持一些基本信息；然后在收到ACK时检查SYN Cache队列，如果能找到合适的项，那么开始建立TCP连接，然后删除SYN Cache中的项。 （2）SYN Cookie。在ACK到达之前不分配任何资源，服务器构造TCP SYN + ACK数据包中的seq为特定的初始值，即SYN Cookie。客户端返回值为n+1，服务器把返回值减去1，即可得到syncookie。取出其中的时间进行对比，计算是否正确。 sudo netwox 76 -i ${攻击IP地址} -p ${端口号} nmap详细介绍 -sT（全开）建立连接 -sS（半开）不建立连接 -sA扫描。顾名思义，-sA扫描是通过设置ACK位进行扫描的方法。ACK数据包不会启动会话建立，所以比较隐蔽；同时，因为ACK数据包不会单独出现，所以，对于端口，不管是开放的还是关闭的，如果收到一个不请自来的ACK数据包，都会发一个RST包。那这样的话，ACK扫描就不可能识别端口的开放和关闭情况。那么它有什么用呢？它可以识别端口有没有被过滤。（如果过滤是无响应，不管是否关闭都会返回RST） -sF（FIN SCAN）开放/被过滤的端口无响应，关闭的端口生成RST。 当扫描对象被防火墙保护，譬如所有的SYN包都被过滤的情况下，-sS型扫描不能成功；但是-sA和-sF一般不是重点防御对象，所以可以经由这两种的扫描获得有用的信息。 端口扫描的原理是什么？ 首先一个个地尝试与一些端口的连接，如果端口有响应，并且能够建立起连接，那么就能够判断得出来，这个端口是open的，之后主动发出RST中断即可。如果是close的端口，那么会收到主机主动的发送一个RST数据包。 nmap -sS和nmap -sT的区别是什么？ tcp connect（-sT）扫描，和TCP SYN（半开-sS）扫描。可以判断三种状态。 普通权限会建立了连接，连接记录被主机log下来；超级权限下可以只发送第一次握手数据包，之后RST，不会建立完整的连接。 nmap -sA扫描的原理是什么？ 作用是判断端口有没有被过滤。 nmap会构造一个ACK数据包（设置ACK位）并发送给目的主机的某一端口。对于端口，不管是开放的还是关闭的，如果收到一个不请自来的ACK数据包，都会发一个RST包。而如果端口被防火墙过滤了，则不会对该数据包作出响应。 补充：nmap -sF/-sX/-sN作用是验证端口是否关闭，关闭时回复RST，打开和过滤不回复。namp fragment扫描（-f）将数据包拆分成若干个。 nmap idle扫描的原理是什么？ 每发一个IP数据包，很多操作系统对identifier字段简单地增加1； （1）发送SYN/ACK探测Zombie的RST中IP ID并记录下来； （2）扫描这个RST数据包，并伪造Zombie主机发送SYN数据包给目标主机。目标端口开启，Zombie主机会给目标主机发送一个RST，IP ID加1；端口关闭或过滤，则会忽略收到的RST； （3）再探测Zombie主机的IP ID，比较两次得到IP ID值。如果IP ID多了2则表示目标端口开启，多了1表示目标端口关闭，大于2表示多发了数据包。 注明：隐蔽且可以绕过防火墙（zombie主机是有访问权限的主机），但是无法区分端口关闭和过滤的情况。 防火墙 iptables是状态防火墙。状态防火墙相比于包过滤防火墙的优点是什么？ 包过滤防火墙 通过ACL（Access Control List）规则控制数据流的。IP数据包中最明显最核心的五元素就是，源地址、目标地址、协议、源端口sport、目标端口dport。包过滤主要也就是根据这些包头部的元素进行判断。 缺点：是1. 难以处理分片【IP碎片攻击】。2. 不支持某些复杂的协议。3. 不能防止应用层等恶意攻击，原因很简单，因为它根本不识别应用层的数据。 应用级网关代理防火墙 优点：对数据的控制直接上升到应用层，对数据包检测非常充分。 缺点：同时为了实现这一点，对于每一个服务应用，写要编写特定的安全代理程序，也即相应的客户端与服务器端程序。 状态检测防火墙/动态包过滤防火墙 通信过程中的会话数据包不是一个个完全独立的数据包，而是有前后连接状态的。在接收到连接建立请求时，就可以建立一张表，在表中存储相关的各个连接的信息，建立连接状态规则，基于这个表对进入和出去的数据包进行匹配。 优点：由于不需要对每个数据包进行规则检查，而是一个连接的后续数据包直接进行状态检查，从而使得性能得到了较大提高；而且，由于状态表是动态的，因而可以有选择地、动态地开放关闭端口，使得安全性得到进一步地提高；隔离客户端和服务器，充当代理。 NAT的作用是什么？ NAT（网络地址转换）是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。因此NAT在一定程度上，能够有效的解决公网地址不足的问题。 NAT表用于IP地址或端口的转换，一般用于共享上网或特殊端口的转换服务。（s/d/pnat，地址/目标地址/目标端口转换） sudo iptables –P INPUT DROP； iptables -A INPUT -p tcp --sport 80 -j ACCEPT 这两条语句的作用是什么？ （1）在INPUT链中制定丢弃/过滤所有目的地址是本机的数据报的策略；（-P，制定链表的策略） （2）在INPUT链尾增加一条过滤规则，接收目的地址是本机，源端口是80的tcp数据包。（-A，追加新规则于指定链的尾部） To do iptables NF_IP_PRE_ROUTING：刚刚进入网络层的数据包通过此点（刚刚进行完版本号，校验和等检测）， 目的地址转换在此点进行； NF_IP_LOCAL_IN：经路由查找后，送往本机的通过此检查点，INPUT包过滤在此点进行； NF_IP_FORWARD：要转发的包通过此检测点，FORWORD包过滤在此点进行； NF_IP_POST_ROUTING：所有马上便要通过网络设备出去的包通过此检测点，内置的源地址转换功能（包括地址伪装）在此点进行； NF_IP_LOCAL_OUT：本机进程发出的包通过此检测点，OUTPUT包过滤在此点进行。 代理设置 sudo iptables -t nat -A PREROUTING -p tcp -s 172.16.192.1 --dport 8123 -j DNAT --to-destination 172.16.192.184:80 sudo iptables -t nat -A POSTROUTING -p tcp -s 172.16.192.1 -j SNAT --to-source 172.16.192.185 sudo iptables -t nat -A PREROUTING -p tcp -s 172.16.192.184 --sport 80 -j DNAT --to-destination 172.16.192.1 sudo iptables -t nat -A POSTROUTING -p tcp -s 172.16.192.184 --sport 80 -j SNAT --to-source 172.16.192.185:8123 TYPE(8-bit): identifies the message，可以用于–icmp-type类型 0:Echo Reply (ICMP Echo即ping) 3:Destination Unreachable 5:Redirect (change route) 8:Echo Request filter的五条链： PREROUTING链（处理目的地址）上一般的动作是DNAT，而POSTROUTING链（处理源地址）上的动作一般是SNAT。 Rootkit 什么是rootkit？ Rootkit是一种黑客安全工具，用于捕获进出计算机的密码和消息流量，允许黑客为系统提供后门，掩盖系统被破坏的事实，等等。其三要素是：隐藏、操纵、收集数据。 Rootkit的作用在于“能维持root权限的一套工具”。它的目的是隐藏自己以及恶意程序，达到长期在目的主机存在并收集信息的目的。Rootkit一般和后门等程序结合使用，帮忙隐藏后门的踪迹。 LKM的好处是什么？ 可加载内核模块（Loadable Kernel Module，LKM），是一段运行在内核空间的代码，可以动态热加载，可以访问操作系统最核心的部分。 不用重新编译内核和重启系统。 优点：动态加载，在不重编译内核和重启系统的条件下对类Unix系统的系统内核进行修改和扩展。否则的话，对Kernel代码的任何修改，都需要重新编译Kernel，大大浪费了时间和效率。 补充——权限： 当用户需要改变权限的时候，就需要更换用户ID或者组ID。为了实现这种机制，引入了真实UID（real UID）、有效UID（effective UID）以及 保存的UID（saved set-user-ID）的概念。 Root作为特权用户，UID=0；新注册用户一般是1000开始。使用getuid()和geteuid()可以获得当前进程的真实ID和有效ID。 中断向量表（128号异常处理函数sys_call）、系统调用表 请描述系统调用劫持的过程。 为了篡改系统调用服务例程sys_xyz()。 （1）我们首先需要找到sys_call_table的地址（虽然32位和64位计算机有所不同，但是思路都是先找到系统处理函数地址，反汇编找到系统调用表SCT地址）。sys_call_table的地址是加载内核之后形成的，因此不同的系统的值也不一样。 （2）篡改系统调用，将SCT表中指向正常的系统调用的指针，改成我们自己的函数地址。首先，要对SCT取消写保护，通过设置cr0寄存器的WP位为0，禁止CPU上的写保护。写完之后恢复写保护，防止SCT被其他进程意外篡改。 （3）实现自己的系统调用函数，一般来说，主要是对系统原有的结果进行过滤，注意需要从用户态将数据拷贝到内核态。 方法：修改虚拟文件系统、利用IDT表找到SCT位置、用自己的中断描述符替换0x80 请解释，为何Unix可以做到一切皆文件。 虚拟文件系统（Virtual File System, 简称 VFS）， 是 Linux 内核中的一个软件层，用于给用户空间的程序提供文件系统接口；同时，它也提供了内核中的一个抽象功能，允许不同的文件系统共存。系统中所有的文件系统不但依赖 VFS 共存，而且也依靠 VFS 协同工作。 linux有一个系统打开文件表。 为了能够支持各种实际文件系统，VFS 定义了所有文件系统都支持的基本的、概念上的接口和数据结构；一个实际的文件系统想要被 Linux 支持，就必须提供一个符合VFS标准 的接口，才能与 VFS协同工作。 相同API的I/O操作 （1）向上，对应用层提供一个标准的文件操作接口； （2）对下，对文件系统提供一个标准的接口，以便其他操作系统的文件系统可以方便的移植到Linux上； （3）VFS内部则通过一系列高效的管理机制，使得底层文件系统不需沉溺到复杂的内核操作，即可获得高性能； （4）此外VFS把一些复杂的操作尽量抽象到VFS内部，使得底层文件系统实现更简单。 更高层次的系统调用如下： sys_getdents-> iterate_dir-> struct file_operations 里的iterate->省略若干层次 -> struct dir_context 里的actor(mostly filldir)。 要达到隐藏文件的目的，我们需要hooking filldir，在hooking function中去掉我们需要隐藏的文件记录，不填到缓冲区，这样应用程序就收不到相应的记录，也就打到了隐藏文件的目的。 具体思路是hooking相应目录的iterate，把dir_context的actor改为fake filldir，fake filldir把隐藏的文件过滤。 u+s chmod u+s temp — 为temp文件加上setuid标志. (setuid 只对文件有效) 缓冲区溢出 缓冲区溢出就是写入到缓冲区或者从缓冲区读取的数据超出了缓冲区可以容纳的范围。 esp指向堆栈顶部的地址；ebp指向堆栈底部的地址；cs eip指向当前正在执行的指令的地址。 什么是返回地址？ 当一个程序调用一个函数时，该函数会开始调用其他函数等操作，然后返回调用它的函数。要返回调用函数，必须有一个调用函数的记录：执行应该从函数调用指令后的指令恢复。该指令的地址称为返回地址。 每当调用一个函数时，返回地址都会被压入堆栈。每当函数返回时，返回地址都会从堆栈中弹出，处理器开始执行该地址的指令。 汇编语言中，call指令的作用是什么？ 函数调用指令，执行调用函数。即将先将call指令的下一条指令的CS和IP入栈，再转移到调用的子程序。 操作数？ 请描述当函数调用发生时，进程地址空间中栈帧的变化。 函数调用指令call执行时，堆栈指针esp递减4个字节（32位），并且调用后的指令地址（返回地址）被写入现在由esp引用的存储器位置，即返回地址被压入栈。然后将eip设置为指定为要调用的函数的地址，并从该地址继续执行。 调用函数执行完毕，函数返回指令ret执行（不占用任何操作数），处理器首先从esp中包含的地址中读取值，然后将esp增加4个字节 ，从堆栈中弹出返回地址。 eip设置为此值，并从该地址继续执行。返回调用前上下文。 如何防止缓冲区溢出攻击。 （1）OS：为了防御缓冲区溢出攻击，编译器进行了canary金丝雀保护（在缓冲区和控制信息间插入一个 canary word，看这个值是否被修改）和防止栈运行等防御。 （2）为了防止猜测栈起始地址，栈起始地址随机化（randomize_va_space）。 （3）限制可执行代码的区域，判断ret地址区域是否改变。 破解：将 ShellCode 放在 large_string 的中部,而前面则一律填充为 NOP 指令(NOP 指令是一个任何事都不做的指令,主要用于延时操作），只要猜测的地址落在NOP指令串中，程序就会一直执行到shellcode。 攻击原理：将shellcode置于内存的某处，然后通过缓冲区溢出将返回地址指向shellcode。 三个实验 实验一 ICMP重定向攻击 内容 请实现ICMP重定向攻击。 实验二 NETFILTER编程 使用iptables命令实现代理。需要3台机器（2台虚拟机+主机）进行演示。 基于netfilter，实现对使用HTTP协议的网站的用户名和密码的窃取。 实验三 通过使用劫持技术，在启动backdoor的情况下，篡改netstat的结果，使其不显示侦听端口。 网络命令 ping ifconfig traceroute Nslookup 域名查询 whois 查询数据库 netstat 显示网络连接 netstat -s statistic netstat -p with pid netstat -a list all ports netstat -at list all tcp port netstat -au list all udp ports netstat -l list all listening ports; netstat -lt; netstat -lu; netstat -r display routing information; netstat -i interface information; tcpdump tcpdump是一个用于网络抓包工具，提供源代码，公开接口，具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。tcpdump默认安装在Linux系统中，由于需要将网络接口设置为混杂模式，普通用户不能正常执行，具备root权限的用户可以执行它来获取网络上的信息。 netcat netcat是一个通过TCP/UDP在网络中进行读写数据工具（命令），主要用于调试领域、传输领域以及攻击领域。利用该工具，可以将网络中一端的数据完整的发送至另一台主机终端显示或存储，常见的应用为文件传输、即时通信、传输流媒体或者作为用来验证服务器的独立的客户端。 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Tool/":{"url":"Tool/","title":"开发常用工具","keywords":"","body":"开发常用的工具 开发常用工具 Charles Git By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Tool/IDEA.html":{"url":"Tool/IDEA.html","title":"IDE","keywords":"","body":"IDEA使用技巧 快捷coding psvm sout for循环 调试springboot项目 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Tool/Charles.html":{"url":"Tool/Charles.html","title":"Charles","keywords":"","body":"Charles使用教程 简介 当在开发APP后台的过程中，免不了与APP的开发同学进行联调。 这时候单纯的看日志进行问题定位是较为麻烦的。 使用Charles进行抓包，查看具体调用的接口和查看接口调用的返回结果是一种有效的方式。 教程环境 MacOS iOS Charles4.5.6 保证电脑和手机在同一网络下，各个教程的环境应该差别不大。 Charles下载 下载地址 Charles配置 这时Charles已经可以抓取HTTP的包，这时候会发现HTTPS的包还是无法识别。 Charles HTTPS抓包配置 Charles配置安装证书 信任证书 iOS上安装相应的CA证书 iOS访问chls.pro/ssl 下载证书 并且在以下两个位置信任证书 设置->通用->关于本机->证书信任设置 设置->通用->描述文件 Charles添加需要抓取的IP iOS设置代理 填入电脑的IP和端口号 结束 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"Tool/Git.html":{"url":"Tool/Git.html","title":"Git","keywords":"","body":"Git和GitHub使用 安装 Git官方网站: https://git-scm.com/ Git完整命令手册地址: http://git-scm.com/docs 查看 git version config设置 设置用户名 git config --global user.name \"username\" 设置邮箱 git config --global user.email username@example.com 设置代理提速(解决clone速度较慢的问题) 设置代理(端口号需要自己设置) git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy 建立仓库 建立本地仓库（直接使用命令创建或者进入文件夹后使用git init） git init [project-name] 克隆项目 git clone [url] 修改管理 查看修改 git status 比对还未暂存的(未add) git diff 将修改提交到暂存区 git add [file] 比对暂存区与修改前区别 git diff --staged 从暂存区删去文件修改 git reset [file] commit提交 git commit -m \"[descriptive message]\" 修改同步 获取远程代码 git fetch [bookmark] 将branch合入到当前分支 git merge [bookmark]/[branch] 推送本地commit到远程 git push [alias] [branch] 删除git pull相当于git fetch和git merge组合 git pull 回滚commit 回滚到对应commit但修改不消失 git reset [commit] 回滚到对应commit所有修改消失 git reset --hard [commit] 查看历史提交修改 当前分支的提交记录 git log 某个文件的修改提交记录 git log --follow [file] 查看两个分支的代码区别 git diff [first-branch]...[second-branch] 查看某个commit号的修改 git show [commit] branch分支管理 查看分支 git branch 创建分支 git branch [branch-name] 切换到对应分支 git checkout [branch-name] 删除分支 git branch -d [branch-name] 合并分支修改(将branch-name中的修改合并到当前分支) git merge [branch-name] tag标签管理 查看标签 git tag 创建标签(默认创建当前branch的最近commit) git tag [tag-name] 创建历史commit的标签(给指定的commit打标签) git tag [tag-name] [commit-number] 删除标签 git tag -d [tag-name] Patch管理 Git与GitHub echo \"# repository name\" >> README.md git init git add README.md git commit -m \"first commit\" git remote add origin [github repository url] git push -u origin master By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BuildTools/":{"url":"BuildTools/","title":"构建工具","keywords":"","body":"构建简介 什么是构建 构建包括编译、运行单元测试、生成文档、打包和部署。 主流的Java构建工具 Maven Gradle 主流的C、C++构建工具 GNU Make CMake By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BuildTools/Gradle.html":{"url":"BuildTools/Gradle.html","title":"Gradle","keywords":"","body":"Gradle By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BuildTools/Maven.html":{"url":"BuildTools/Maven.html","title":"Maven","keywords":"","body":"Maven 简介 主流的Java构建工具之一 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BookList/":{"url":"BookList/","title":"书单","keywords":"","body":"书单 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BookList/计算机基础.html":{"url":"BookList/计算机基础.html","title":"计算机基础","keywords":"","body":"计算机基础书单 数据结构与算法 《算法》 《算法导论》 计算机体系结构 《深入理解计算机系统》 编译原理 《编译原理：原理、技术与工具》 计算机网络 《计算机网络》 《TCP/IP详解》 数据库 高性能MySQL（第三版） By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BookList/LinuxUnix.html":{"url":"BookList/LinuxUnix.html","title":"LinuxUnix","keywords":"","body":"LinuxUnix书单 Linux入门使用 《鸟哥的Linux私房菜》 Linux内核 《深入理解Linux内核》 Unix编程 《Unix环境高级编程》 《Unix网络编程卷1：套接字联网API》 《Unix网络编程卷2：进程间通信》 By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "},"BookList/Java.html":{"url":"BookList/Java.html","title":"Java","keywords":"","body":"Java 书单 Java基础 Java核心技术 Java编程思想 Java虚拟机 深入理解Java虚拟机 Java编程指导 Effective Java By Salted-Fish            此页面修订于： 2021-03-24 15:36:33 "}}