# 垃圾收集器与内存分配策略

## 概述
主要解决以下问题
+ 哪些内存需要回收
+ 什么时候回收
+ 如何回收

## 判断对象是否可以存活

### 引用计数算法
在对象中添加一个引用计数器，每当有一个地方引用就加1，少一个引用就减1。
主流的不采用引用计数法。
优点：原理简单、判断效率高。
缺点：循环引用无法判断。


### 可达性分析法
通过一系列称为GC Roots的根对象做为起始节点集。
从这些节点开始根据引用关系向下搜索，搜索过程中所走过的路径称为引用链。
如果某个对象没有引用链，则说明此对象不再被使用。

GC Root主要包括以下几类
+ 在虚拟机栈(栈帧中的本地变量表)中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
+ 在方法区中类静态属性引用的对象，例如Java类的引用类型静态变量。
+ 在方法区常量引用的对象，例如字符串常量池，例如字符串常量池里的引用。
+ 在本地方法栈中JNI(Native方法)引用的对象。
+ Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻内存的异常对象(比如NullPointException、OutOfMemoryError)等，还有系统类加载器。
+ 所有被同步锁(synchronized)持有的对象
+ 反应Java虚拟机内部情况的JMXBean、JVM TI中注册的回调、本地代码缓存等。

除了这些固定的之外。根据垃圾收集器的不同和当前回收区域的不同，还会有其他对象临时性加入。
比如在局部回收时，本区域的对象可能被其他区域所引用。此时关联区域的对象也会被加入GCRoots

### 引用类型

+ 强引用。最平常使用的类型。只要引用还在，垃圾收集器永远不会回收

+ 软引用。在系统将要发生内存异常钱，会把这些对象列进回收范围内进行第二次回收。使用SoftReference类实现。

+ 弱引用。只能生存到下一次垃圾收集发生为止。下一次垃圾收集开始时，都会被回收掉。WeakReference实现

+ 虚引用。为一个对象设置虚引用关联的唯一目的是为了能在这个对象被回收时收到一个系统通知。PhantomReference
虚引用主要是为了使得指向的对象被回收时可以收到通知。这时可以根据情况进行相应的处理。

### 标记不可到达后
+ 即使被标记为不可达，也不是非死不可。
+ 宣布一个对象死亡，要经历两次标记。
+ 没有引用链是第一次，第二次是是否需要执行finalize()方法
+ 在finalize()中只要重新与引用链上的任何一个对象建立关联即可。(不建议使用)


### 方法区回收
在方法区进行回收性价比是比较低的。
主要回收以下两部分：
+ 废弃的常量 
    + 如字符串"java"，没有一个字符串引用，则会被回收
+ 不再使用的类型。类型回收的条件
    + 该类的所有实例都已经被回收
    + 加载该类的类加载器都已经被回收(很难达成，除了OSGi、JSP的重加载)
    + 该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力。免得方法区有过大的内存压力。

## 垃圾收集算法

### 分代收集理论

+ 弱分代假说：绝大多数对象都是朝生夕灭的
+ 强分代假说：经历多次GC都没有被收集的对象能存活更久
+ 跨代引用假说：跨代引用相对于同代引用来说仅占极少数




