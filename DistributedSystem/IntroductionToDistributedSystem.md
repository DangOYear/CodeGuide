# 分布式系统简介

## ACID、CAP、BASE理论

+ ACID
  + 原子性
  + 一致性
  + 隔离性
  + 持久性

+ CAP理论：
  + C.一致性 
  + A.可用性 
  + P.分区容错性
  + 往往无法同时满足
+ BASE理论:
  + Basically Available（基本可用）
    + 在出现不可预知故障时候，允许使用部分可用性
  + Soft state（软状态）
    + 允许系统中的数据存在中间状态，允许数据同步存在时延
  + Eventually consistent（最终一致性）
    + 系统中所有的数据副本，经过一段时间的同步后，最终能够达到一个一致的状态（不同于强一致性）。

## 2PC

To do

## 3PC

To do

## Paxos

To do

## 一致性Hash



## 分布式锁

### Redis实现

#### 1.使用setnx+expire实现

+ 问题
  + setnx和expire不具有原子性，容易出错

+ 解决方法
  + lua脚本，同时包含setnx和expire两条指令

#### 2.使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令

- EX seconds: 设定过期时间，单位为秒
- PX milliseconds: 设定过期时间，单位为毫秒
- NX: 仅当key不存在时设置值
- XX: 仅当key存在时设置值

value值最好具有唯一性。可以使用UUID等方式进行设置。

释放锁时判断一下value值再释放。

分布式情况下可能会出问题。

比如有节点A和节点B，节点A挂掉，尚未同步到节点B。这时出错。

#### redlock

具体步骤

假设有5个redis节点

+ 获取当前Unix时间，以毫秒为单位
+ 依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁
  当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等
+ 客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的Redis节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功
+ 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要
+ 如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁，无论Redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题

[分布式锁](https://juejin.im/post/6844903830442737671)

### ZooKeeper实现

[ZooKeeper实现](https://juejin.im/post/6844903729406148622)

假设有客户端A和客户端B竞争一把锁lock

获取锁就是在lock节点下创建一个xxxx1节点，比如A创建了xxxx1获取到了锁，这时候客户端B来获取锁，创建xxxx2节点，发现自己并不是第一个节点。就去坚挺xxxxx1节点（ZooKeeper特性）。客户端A处理好后，删除了节点，这时客户端B会收到ZooKeeper的提醒。每次加锁都是监听上一个节点。

如果正在获取锁的节点宕机，ZooKeeper能感知到，会把它的节点进行删除操作。



## 使用ZooKeeper和Redis的区别

- Redis获取锁的方式简单粗暴，获取会不断尝试获取锁，比较消耗性能。Zookeeper是提醒型。
- Redis 的设计定位决定了数据不是强一致性的，可能会出现问题。锁的模型不够健壮。
- 即便使用 Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题**严重依赖时钟，比如有些服务器时钟走的特别快，可能会出问题**
- 现在使用Redis的情况比较多，因为Redis的性能好，ZooKeeper如果有较多的集群申请加锁、释放锁，压力会比较大。

